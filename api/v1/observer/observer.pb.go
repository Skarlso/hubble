// Code generated by protoc-gen-go. DO NOT EDIT.
// source: observer.proto

package observer

import (
	context "context"
	fmt "fmt"
	types "github.com/gogo/protobuf/types"
	proto "github.com/golang/protobuf/proto"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
	math "math"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.ProtoPackageIsVersion3 // please upgrade the proto package

// ProtocolMessageType enumerates the type of messages the server can return
// to the client.
type ProtocolMessageType int32

const (
	ProtocolMessageType_UNKNOWN_PROTOCOL_MESSAGE_TYPE  ProtocolMessageType = 0
	ProtocolMessageType_PROGRESS_PROTOCOL_MESSAGE_TYPE ProtocolMessageType = 1
	ProtocolMessageType_ERROR_PROTOCOL_MESSAGE_TYPE    ProtocolMessageType = 2
)

var ProtocolMessageType_name = map[int32]string{
	0: "UNKNOWN_PROTOCOL_MESSAGE_TYPE",
	1: "PROGRESS_PROTOCOL_MESSAGE_TYPE",
	2: "ERROR_PROTOCOL_MESSAGE_TYPE",
}

var ProtocolMessageType_value = map[string]int32{
	"UNKNOWN_PROTOCOL_MESSAGE_TYPE":  0,
	"PROGRESS_PROTOCOL_MESSAGE_TYPE": 1,
	"ERROR_PROTOCOL_MESSAGE_TYPE":    2,
}

func (x ProtocolMessageType) String() string {
	return proto.EnumName(ProtocolMessageType_name, int32(x))
}

func (ProtocolMessageType) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_f64efb003ca9295a, []int{0}
}

type FlowType int32

const (
	FlowType_UNKNOWN_TYPE FlowType = 0
	FlowType_L3_L4        FlowType = 1
	FlowType_L7           FlowType = 2
)

var FlowType_name = map[int32]string{
	0: "UNKNOWN_TYPE",
	1: "L3_L4",
	2: "L7",
}

var FlowType_value = map[string]int32{
	"UNKNOWN_TYPE": 0,
	"L3_L4":        1,
	"L7":           2,
}

func (x FlowType) String() string {
	return proto.EnumName(FlowType_name, int32(x))
}

func (FlowType) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_f64efb003ca9295a, []int{1}
}

// This enum corresponds to Cilium's L7 accesslog FlowType:
//   https://github.com/cilium/cilium/blob/728c79e427438ab6f8d9375b62fccd6fed4ace3a/pkg/proxy/accesslog/record.go#L26
type L7FlowType int32

const (
	L7FlowType_UNKNOWN_L7_TYPE L7FlowType = 0
	L7FlowType_REQUEST         L7FlowType = 1
	L7FlowType_RESPONSE        L7FlowType = 2
	L7FlowType_SAMPLE          L7FlowType = 3
)

var L7FlowType_name = map[int32]string{
	0: "UNKNOWN_L7_TYPE",
	1: "REQUEST",
	2: "RESPONSE",
	3: "SAMPLE",
}

var L7FlowType_value = map[string]int32{
	"UNKNOWN_L7_TYPE": 0,
	"REQUEST":         1,
	"RESPONSE":        2,
	"SAMPLE":          3,
}

func (x L7FlowType) String() string {
	return proto.EnumName(L7FlowType_name, int32(x))
}

func (L7FlowType) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_f64efb003ca9295a, []int{2}
}

type IPVersion int32

const (
	IPVersion_IP_NOT_USED IPVersion = 0
	IPVersion_IPv4        IPVersion = 1
	IPVersion_IPv6        IPVersion = 2
)

var IPVersion_name = map[int32]string{
	0: "IP_NOT_USED",
	1: "IPv4",
	2: "IPv6",
}

var IPVersion_value = map[string]int32{
	"IP_NOT_USED": 0,
	"IPv4":        1,
	"IPv6":        2,
}

func (x IPVersion) String() string {
	return proto.EnumName(IPVersion_name, int32(x))
}

func (IPVersion) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_f64efb003ca9295a, []int{3}
}

type Verdict int32

const (
	Verdict_VERDICT_UNKNOWN Verdict = 0
	Verdict_FORWARDED       Verdict = 1
	Verdict_DROPPED         Verdict = 2
)

var Verdict_name = map[int32]string{
	0: "VERDICT_UNKNOWN",
	1: "FORWARDED",
	2: "DROPPED",
}

var Verdict_value = map[string]int32{
	"VERDICT_UNKNOWN": 0,
	"FORWARDED":       1,
	"DROPPED":         2,
}

func (x Verdict) String() string {
	return proto.EnumName(Verdict_name, int32(x))
}

func (Verdict) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_f64efb003ca9295a, []int{4}
}

// EventType are constants are based on the ones from <linux/perf_event.h>.
type EventType int32

const (
	EventType_UNKNOWN EventType = 0
	// EventSample is equivalent to PERF_RECORD_SAMPLE.
	EventType_EventSample EventType = 9
	// RecordLost is equivalent to PERF_RECORD_LOST.
	EventType_RecordLost EventType = 2
)

var EventType_name = map[int32]string{
	0: "UNKNOWN",
	9: "EventSample",
	2: "RecordLost",
}

var EventType_value = map[string]int32{
	"UNKNOWN":     0,
	"EventSample": 9,
	"RecordLost":  2,
}

func (x EventType) String() string {
	return proto.EnumName(EventType_name, int32(x))
}

func (EventType) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_f64efb003ca9295a, []int{5}
}

type ServerStatusRequest struct {
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *ServerStatusRequest) Reset()         { *m = ServerStatusRequest{} }
func (m *ServerStatusRequest) String() string { return proto.CompactTextString(m) }
func (*ServerStatusRequest) ProtoMessage()    {}
func (*ServerStatusRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_f64efb003ca9295a, []int{0}
}

func (m *ServerStatusRequest) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_ServerStatusRequest.Unmarshal(m, b)
}
func (m *ServerStatusRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_ServerStatusRequest.Marshal(b, m, deterministic)
}
func (m *ServerStatusRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ServerStatusRequest.Merge(m, src)
}
func (m *ServerStatusRequest) XXX_Size() int {
	return xxx_messageInfo_ServerStatusRequest.Size(m)
}
func (m *ServerStatusRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_ServerStatusRequest.DiscardUnknown(m)
}

var xxx_messageInfo_ServerStatusRequest proto.InternalMessageInfo

type ServerStatusResponse struct {
	// number of currently captured flows
	NumFlows uint64 `protobuf:"varint,1,opt,name=num_flows,json=numFlows,proto3" json:"num_flows,omitempty"`
	// maximum capacity of the ring buffer
	MaxFlows             uint64   `protobuf:"varint,2,opt,name=max_flows,json=maxFlows,proto3" json:"max_flows,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *ServerStatusResponse) Reset()         { *m = ServerStatusResponse{} }
func (m *ServerStatusResponse) String() string { return proto.CompactTextString(m) }
func (*ServerStatusResponse) ProtoMessage()    {}
func (*ServerStatusResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_f64efb003ca9295a, []int{1}
}

func (m *ServerStatusResponse) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_ServerStatusResponse.Unmarshal(m, b)
}
func (m *ServerStatusResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_ServerStatusResponse.Marshal(b, m, deterministic)
}
func (m *ServerStatusResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ServerStatusResponse.Merge(m, src)
}
func (m *ServerStatusResponse) XXX_Size() int {
	return xxx_messageInfo_ServerStatusResponse.Size(m)
}
func (m *ServerStatusResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_ServerStatusResponse.DiscardUnknown(m)
}

var xxx_messageInfo_ServerStatusResponse proto.InternalMessageInfo

func (m *ServerStatusResponse) GetNumFlows() uint64 {
	if m != nil {
		return m.NumFlows
	}
	return 0
}

func (m *ServerStatusResponse) GetMaxFlows() uint64 {
	if m != nil {
		return m.MaxFlows
	}
	return 0
}

type GetFlowsRequest struct {
	// Number of flows that should be returned. Incompatible with `since/until`.
	Number uint64 `protobuf:"varint,1,opt,name=number,proto3" json:"number,omitempty"`
	// follow sets when the server should continue to stream flows after
	// printing the last N flows.
	Follow bool `protobuf:"varint,3,opt,name=follow,proto3" json:"follow,omitempty"`
	// blacklist defines a list of filters which have to match for a flow to be
	// excluded from the result.
	// If multiple blacklist filters are specified, only one of them has to
	// match for a flow to be excluded.
	Blacklist []*FlowFilter `protobuf:"bytes,5,rep,name=blacklist,proto3" json:"blacklist,omitempty"`
	// whitelist defines a list of filters which have to match for a flow to be
	// included in the result.
	// If multiple whitelist filters are specified, only one of them has to
	// match for a flow to be included.
	// The whitelist and blacklist can both be specified. In such cases, the
	// set of the returned flows is the set difference `whitelist - blacklist`.
	// In other words, the result will contain all flows matched by the
	// whitelist that are not also simultaneously matched by the blacklist.
	Whitelist []*FlowFilter `protobuf:"bytes,6,rep,name=whitelist,proto3" json:"whitelist,omitempty"`
	// Since this time for returned flows. Incompatible with `number`.
	Since *types.Timestamp `protobuf:"bytes,7,opt,name=since,proto3" json:"since,omitempty"`
	// Until this time for returned flows. Incompatible with `number`.
	Until *types.Timestamp `protobuf:"bytes,8,opt,name=until,proto3" json:"until,omitempty"`
	// Do not dissect and inflate `message Flow`, only return flow.Payload raw data.
	SkipDecoding         bool     `protobuf:"varint,9,opt,name=skip_decoding,json=skipDecoding,proto3" json:"skip_decoding,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *GetFlowsRequest) Reset()         { *m = GetFlowsRequest{} }
func (m *GetFlowsRequest) String() string { return proto.CompactTextString(m) }
func (*GetFlowsRequest) ProtoMessage()    {}
func (*GetFlowsRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_f64efb003ca9295a, []int{2}
}

func (m *GetFlowsRequest) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_GetFlowsRequest.Unmarshal(m, b)
}
func (m *GetFlowsRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_GetFlowsRequest.Marshal(b, m, deterministic)
}
func (m *GetFlowsRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GetFlowsRequest.Merge(m, src)
}
func (m *GetFlowsRequest) XXX_Size() int {
	return xxx_messageInfo_GetFlowsRequest.Size(m)
}
func (m *GetFlowsRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_GetFlowsRequest.DiscardUnknown(m)
}

var xxx_messageInfo_GetFlowsRequest proto.InternalMessageInfo

func (m *GetFlowsRequest) GetNumber() uint64 {
	if m != nil {
		return m.Number
	}
	return 0
}

func (m *GetFlowsRequest) GetFollow() bool {
	if m != nil {
		return m.Follow
	}
	return false
}

func (m *GetFlowsRequest) GetBlacklist() []*FlowFilter {
	if m != nil {
		return m.Blacklist
	}
	return nil
}

func (m *GetFlowsRequest) GetWhitelist() []*FlowFilter {
	if m != nil {
		return m.Whitelist
	}
	return nil
}

func (m *GetFlowsRequest) GetSince() *types.Timestamp {
	if m != nil {
		return m.Since
	}
	return nil
}

func (m *GetFlowsRequest) GetUntil() *types.Timestamp {
	if m != nil {
		return m.Until
	}
	return nil
}

func (m *GetFlowsRequest) GetSkipDecoding() bool {
	if m != nil {
		return m.SkipDecoding
	}
	return false
}

// GetFlowsResponse contains either a flow or a protocol message.
type GetFlowsResponse struct {
	// Types that are valid to be assigned to ResponseTypes:
	//	*GetFlowsResponse_Flow
	//	*GetFlowsResponse_ServerMsg
	ResponseTypes isGetFlowsResponse_ResponseTypes `protobuf_oneof:"response_types"`
	// Name of the node where this event was observed.
	NodeName string `protobuf:"bytes,1000,opt,name=node_name,json=nodeName,proto3" json:"node_name,omitempty"`
	// Timestamp at which this event was observed.
	Time                 *types.Timestamp `protobuf:"bytes,1001,opt,name=time,proto3" json:"time,omitempty"`
	XXX_NoUnkeyedLiteral struct{}         `json:"-"`
	XXX_unrecognized     []byte           `json:"-"`
	XXX_sizecache        int32            `json:"-"`
}

func (m *GetFlowsResponse) Reset()         { *m = GetFlowsResponse{} }
func (m *GetFlowsResponse) String() string { return proto.CompactTextString(m) }
func (*GetFlowsResponse) ProtoMessage()    {}
func (*GetFlowsResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_f64efb003ca9295a, []int{3}
}

func (m *GetFlowsResponse) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_GetFlowsResponse.Unmarshal(m, b)
}
func (m *GetFlowsResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_GetFlowsResponse.Marshal(b, m, deterministic)
}
func (m *GetFlowsResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GetFlowsResponse.Merge(m, src)
}
func (m *GetFlowsResponse) XXX_Size() int {
	return xxx_messageInfo_GetFlowsResponse.Size(m)
}
func (m *GetFlowsResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_GetFlowsResponse.DiscardUnknown(m)
}

var xxx_messageInfo_GetFlowsResponse proto.InternalMessageInfo

type isGetFlowsResponse_ResponseTypes interface {
	isGetFlowsResponse_ResponseTypes()
}

type GetFlowsResponse_Flow struct {
	Flow *Flow `protobuf:"bytes,1,opt,name=flow,proto3,oneof"`
}

type GetFlowsResponse_ServerMsg struct {
	ServerMsg *ProtocolMessage `protobuf:"bytes,2,opt,name=server_msg,json=serverMsg,proto3,oneof"`
}

func (*GetFlowsResponse_Flow) isGetFlowsResponse_ResponseTypes() {}

func (*GetFlowsResponse_ServerMsg) isGetFlowsResponse_ResponseTypes() {}

func (m *GetFlowsResponse) GetResponseTypes() isGetFlowsResponse_ResponseTypes {
	if m != nil {
		return m.ResponseTypes
	}
	return nil
}

func (m *GetFlowsResponse) GetFlow() *Flow {
	if x, ok := m.GetResponseTypes().(*GetFlowsResponse_Flow); ok {
		return x.Flow
	}
	return nil
}

func (m *GetFlowsResponse) GetServerMsg() *ProtocolMessage {
	if x, ok := m.GetResponseTypes().(*GetFlowsResponse_ServerMsg); ok {
		return x.ServerMsg
	}
	return nil
}

func (m *GetFlowsResponse) GetNodeName() string {
	if m != nil {
		return m.NodeName
	}
	return ""
}

func (m *GetFlowsResponse) GetTime() *types.Timestamp {
	if m != nil {
		return m.Time
	}
	return nil
}

// XXX_OneofWrappers is for the internal use of the proto package.
func (*GetFlowsResponse) XXX_OneofWrappers() []interface{} {
	return []interface{}{
		(*GetFlowsResponse_Flow)(nil),
		(*GetFlowsResponse_ServerMsg)(nil),
	}
}

// ProtocolMessage is a type of message type that can sent by the server to
// inform the client with its current status.
type ProtocolMessage struct {
	// Types that are valid to be assigned to Msg:
	//	*ProtocolMessage_Info
	Msg                  isProtocolMessage_Msg `protobuf_oneof:"msg"`
	XXX_NoUnkeyedLiteral struct{}              `json:"-"`
	XXX_unrecognized     []byte                `json:"-"`
	XXX_sizecache        int32                 `json:"-"`
}

func (m *ProtocolMessage) Reset()         { *m = ProtocolMessage{} }
func (m *ProtocolMessage) String() string { return proto.CompactTextString(m) }
func (*ProtocolMessage) ProtoMessage()    {}
func (*ProtocolMessage) Descriptor() ([]byte, []int) {
	return fileDescriptor_f64efb003ca9295a, []int{4}
}

func (m *ProtocolMessage) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_ProtocolMessage.Unmarshal(m, b)
}
func (m *ProtocolMessage) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_ProtocolMessage.Marshal(b, m, deterministic)
}
func (m *ProtocolMessage) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ProtocolMessage.Merge(m, src)
}
func (m *ProtocolMessage) XXX_Size() int {
	return xxx_messageInfo_ProtocolMessage.Size(m)
}
func (m *ProtocolMessage) XXX_DiscardUnknown() {
	xxx_messageInfo_ProtocolMessage.DiscardUnknown(m)
}

var xxx_messageInfo_ProtocolMessage proto.InternalMessageInfo

type isProtocolMessage_Msg interface {
	isProtocolMessage_Msg()
}

type ProtocolMessage_Info struct {
	Info *ProtocolMessageInfo `protobuf:"bytes,1,opt,name=info,proto3,oneof"`
}

func (*ProtocolMessage_Info) isProtocolMessage_Msg() {}

func (m *ProtocolMessage) GetMsg() isProtocolMessage_Msg {
	if m != nil {
		return m.Msg
	}
	return nil
}

func (m *ProtocolMessage) GetInfo() *ProtocolMessageInfo {
	if x, ok := m.GetMsg().(*ProtocolMessage_Info); ok {
		return x.Info
	}
	return nil
}

// XXX_OneofWrappers is for the internal use of the proto package.
func (*ProtocolMessage) XXX_OneofWrappers() []interface{} {
	return []interface{}{
		(*ProtocolMessage_Info)(nil),
	}
}

// ProtocolMessageInfo is an informational message type that can sent by the server.
type ProtocolMessageInfo struct {
	Msg                  string              `protobuf:"bytes,1,opt,name=msg,proto3" json:"msg,omitempty"`
	Type                 ProtocolMessageType `protobuf:"varint,2,opt,name=type,proto3,enum=observer.ProtocolMessageType" json:"type,omitempty"`
	XXX_NoUnkeyedLiteral struct{}            `json:"-"`
	XXX_unrecognized     []byte              `json:"-"`
	XXX_sizecache        int32               `json:"-"`
}

func (m *ProtocolMessageInfo) Reset()         { *m = ProtocolMessageInfo{} }
func (m *ProtocolMessageInfo) String() string { return proto.CompactTextString(m) }
func (*ProtocolMessageInfo) ProtoMessage()    {}
func (*ProtocolMessageInfo) Descriptor() ([]byte, []int) {
	return fileDescriptor_f64efb003ca9295a, []int{5}
}

func (m *ProtocolMessageInfo) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_ProtocolMessageInfo.Unmarshal(m, b)
}
func (m *ProtocolMessageInfo) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_ProtocolMessageInfo.Marshal(b, m, deterministic)
}
func (m *ProtocolMessageInfo) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ProtocolMessageInfo.Merge(m, src)
}
func (m *ProtocolMessageInfo) XXX_Size() int {
	return xxx_messageInfo_ProtocolMessageInfo.Size(m)
}
func (m *ProtocolMessageInfo) XXX_DiscardUnknown() {
	xxx_messageInfo_ProtocolMessageInfo.DiscardUnknown(m)
}

var xxx_messageInfo_ProtocolMessageInfo proto.InternalMessageInfo

func (m *ProtocolMessageInfo) GetMsg() string {
	if m != nil {
		return m.Msg
	}
	return ""
}

func (m *ProtocolMessageInfo) GetType() ProtocolMessageType {
	if m != nil {
		return m.Type
	}
	return ProtocolMessageType_UNKNOWN_PROTOCOL_MESSAGE_TYPE
}

type Flow struct {
	Time    *types.Timestamp `protobuf:"bytes,1,opt,name=time,proto3" json:"time,omitempty"`
	Verdict Verdict          `protobuf:"varint,2,opt,name=verdict,proto3,enum=observer.Verdict" json:"verdict,omitempty"`
	// only applicable to Verdict = DROPPED.
	DropReason uint32 `protobuf:"varint,3,opt,name=drop_reason,json=dropReason,proto3" json:"drop_reason,omitempty"`
	// l2
	Ethernet *Ethernet `protobuf:"bytes,4,opt,name=ethernet,proto3" json:"ethernet,omitempty"`
	// l3
	IP *IP `protobuf:"bytes,5,opt,name=IP,proto3" json:"IP,omitempty"`
	// l4
	L4          *Layer4   `protobuf:"bytes,6,opt,name=l4,proto3" json:"l4,omitempty"`
	Source      *Endpoint `protobuf:"bytes,8,opt,name=source,proto3" json:"source,omitempty"`
	Destination *Endpoint `protobuf:"bytes,9,opt,name=destination,proto3" json:"destination,omitempty"`
	Type        FlowType  `protobuf:"varint,10,opt,name=Type,proto3,enum=observer.FlowType" json:"Type,omitempty"`
	// NodeName is the name of the node from which this Flow was captured.
	NodeName string `protobuf:"bytes,11,opt,name=node_name,json=nodeName,proto3" json:"node_name,omitempty"`
	// Payload of the original monitor notification in full. Used at the moment
	// primarily for transitioning to GetFlows, but there may be some sense to
	// keep this in here forever. This would allow the more sophisticated
	// clients to dissect the data to get at the more obscure things that are
	// not part of the structured API.
	Payload *Payload `protobuf:"bytes,12,opt,name=payload,proto3" json:"payload,omitempty"`
	// all names the source IP can have.
	SourceNames []string `protobuf:"bytes,13,rep,name=source_names,json=sourceNames,proto3" json:"source_names,omitempty"`
	// all names the destination IP can have.
	DestinationNames []string `protobuf:"bytes,14,rep,name=destination_names,json=destinationNames,proto3" json:"destination_names,omitempty"`
	// L7 information. This field is set if and only if FlowType is L7.
	L7    *Layer7 `protobuf:"bytes,15,opt,name=l7,proto3" json:"l7,omitempty"`
	Reply bool    `protobuf:"varint,16,opt,name=reply,proto3" json:"reply,omitempty"`
	// EventType of the originating Cilium event
	EventType *CiliumEventType `protobuf:"bytes,19,opt,name=event_type,json=eventType,proto3" json:"event_type,omitempty"`
	// source_service contains the service name of the source
	SourceService *Service `protobuf:"bytes,20,opt,name=source_service,json=sourceService,proto3" json:"source_service,omitempty"`
	// destination_service contains the service name of the destination
	DestinationService *Service `protobuf:"bytes,21,opt,name=destination_service,json=destinationService,proto3" json:"destination_service,omitempty"`
	// This is a temporary workaround to support summary field for pb.Flow without
	// duplicating logic from the old parser. This field will be removed once we
	// fully migrate to the new parser.
	Summary              string   `protobuf:"bytes,100000,opt,name=Summary,proto3" json:"Summary,omitempty"` // Deprecated: Do not use.
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *Flow) Reset()         { *m = Flow{} }
func (m *Flow) String() string { return proto.CompactTextString(m) }
func (*Flow) ProtoMessage()    {}
func (*Flow) Descriptor() ([]byte, []int) {
	return fileDescriptor_f64efb003ca9295a, []int{6}
}

func (m *Flow) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_Flow.Unmarshal(m, b)
}
func (m *Flow) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_Flow.Marshal(b, m, deterministic)
}
func (m *Flow) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Flow.Merge(m, src)
}
func (m *Flow) XXX_Size() int {
	return xxx_messageInfo_Flow.Size(m)
}
func (m *Flow) XXX_DiscardUnknown() {
	xxx_messageInfo_Flow.DiscardUnknown(m)
}

var xxx_messageInfo_Flow proto.InternalMessageInfo

func (m *Flow) GetTime() *types.Timestamp {
	if m != nil {
		return m.Time
	}
	return nil
}

func (m *Flow) GetVerdict() Verdict {
	if m != nil {
		return m.Verdict
	}
	return Verdict_VERDICT_UNKNOWN
}

func (m *Flow) GetDropReason() uint32 {
	if m != nil {
		return m.DropReason
	}
	return 0
}

func (m *Flow) GetEthernet() *Ethernet {
	if m != nil {
		return m.Ethernet
	}
	return nil
}

func (m *Flow) GetIP() *IP {
	if m != nil {
		return m.IP
	}
	return nil
}

func (m *Flow) GetL4() *Layer4 {
	if m != nil {
		return m.L4
	}
	return nil
}

func (m *Flow) GetSource() *Endpoint {
	if m != nil {
		return m.Source
	}
	return nil
}

func (m *Flow) GetDestination() *Endpoint {
	if m != nil {
		return m.Destination
	}
	return nil
}

func (m *Flow) GetType() FlowType {
	if m != nil {
		return m.Type
	}
	return FlowType_UNKNOWN_TYPE
}

func (m *Flow) GetNodeName() string {
	if m != nil {
		return m.NodeName
	}
	return ""
}

func (m *Flow) GetPayload() *Payload {
	if m != nil {
		return m.Payload
	}
	return nil
}

func (m *Flow) GetSourceNames() []string {
	if m != nil {
		return m.SourceNames
	}
	return nil
}

func (m *Flow) GetDestinationNames() []string {
	if m != nil {
		return m.DestinationNames
	}
	return nil
}

func (m *Flow) GetL7() *Layer7 {
	if m != nil {
		return m.L7
	}
	return nil
}

func (m *Flow) GetReply() bool {
	if m != nil {
		return m.Reply
	}
	return false
}

func (m *Flow) GetEventType() *CiliumEventType {
	if m != nil {
		return m.EventType
	}
	return nil
}

func (m *Flow) GetSourceService() *Service {
	if m != nil {
		return m.SourceService
	}
	return nil
}

func (m *Flow) GetDestinationService() *Service {
	if m != nil {
		return m.DestinationService
	}
	return nil
}

// Deprecated: Do not use.
func (m *Flow) GetSummary() string {
	if m != nil {
		return m.Summary
	}
	return ""
}

type Layer4 struct {
	// Types that are valid to be assigned to Protocol:
	//	*Layer4_TCP
	//	*Layer4_UDP
	//	*Layer4_ICMPv4
	//	*Layer4_ICMPv6
	Protocol             isLayer4_Protocol `protobuf_oneof:"protocol"`
	XXX_NoUnkeyedLiteral struct{}          `json:"-"`
	XXX_unrecognized     []byte            `json:"-"`
	XXX_sizecache        int32             `json:"-"`
}

func (m *Layer4) Reset()         { *m = Layer4{} }
func (m *Layer4) String() string { return proto.CompactTextString(m) }
func (*Layer4) ProtoMessage()    {}
func (*Layer4) Descriptor() ([]byte, []int) {
	return fileDescriptor_f64efb003ca9295a, []int{7}
}

func (m *Layer4) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_Layer4.Unmarshal(m, b)
}
func (m *Layer4) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_Layer4.Marshal(b, m, deterministic)
}
func (m *Layer4) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Layer4.Merge(m, src)
}
func (m *Layer4) XXX_Size() int {
	return xxx_messageInfo_Layer4.Size(m)
}
func (m *Layer4) XXX_DiscardUnknown() {
	xxx_messageInfo_Layer4.DiscardUnknown(m)
}

var xxx_messageInfo_Layer4 proto.InternalMessageInfo

type isLayer4_Protocol interface {
	isLayer4_Protocol()
}

type Layer4_TCP struct {
	TCP *TCP `protobuf:"bytes,1,opt,name=TCP,proto3,oneof"`
}

type Layer4_UDP struct {
	UDP *UDP `protobuf:"bytes,2,opt,name=UDP,proto3,oneof"`
}

type Layer4_ICMPv4 struct {
	ICMPv4 *ICMPv4 `protobuf:"bytes,3,opt,name=ICMPv4,proto3,oneof"`
}

type Layer4_ICMPv6 struct {
	ICMPv6 *ICMPv6 `protobuf:"bytes,4,opt,name=ICMPv6,proto3,oneof"`
}

func (*Layer4_TCP) isLayer4_Protocol() {}

func (*Layer4_UDP) isLayer4_Protocol() {}

func (*Layer4_ICMPv4) isLayer4_Protocol() {}

func (*Layer4_ICMPv6) isLayer4_Protocol() {}

func (m *Layer4) GetProtocol() isLayer4_Protocol {
	if m != nil {
		return m.Protocol
	}
	return nil
}

func (m *Layer4) GetTCP() *TCP {
	if x, ok := m.GetProtocol().(*Layer4_TCP); ok {
		return x.TCP
	}
	return nil
}

func (m *Layer4) GetUDP() *UDP {
	if x, ok := m.GetProtocol().(*Layer4_UDP); ok {
		return x.UDP
	}
	return nil
}

func (m *Layer4) GetICMPv4() *ICMPv4 {
	if x, ok := m.GetProtocol().(*Layer4_ICMPv4); ok {
		return x.ICMPv4
	}
	return nil
}

func (m *Layer4) GetICMPv6() *ICMPv6 {
	if x, ok := m.GetProtocol().(*Layer4_ICMPv6); ok {
		return x.ICMPv6
	}
	return nil
}

// XXX_OneofWrappers is for the internal use of the proto package.
func (*Layer4) XXX_OneofWrappers() []interface{} {
	return []interface{}{
		(*Layer4_TCP)(nil),
		(*Layer4_UDP)(nil),
		(*Layer4_ICMPv4)(nil),
		(*Layer4_ICMPv6)(nil),
	}
}

// Message for L7 flow, which roughly corresponds to Cilium's accesslog LogRecord:
//   https://github.com/cilium/cilium/blob/728c79e427438ab6f8d9375b62fccd6fed4ace3a/pkg/proxy/accesslog/record.go#L141
type Layer7 struct {
	Type L7FlowType `protobuf:"varint,1,opt,name=type,proto3,enum=observer.L7FlowType" json:"type,omitempty"`
	// Latency of the response
	LatencyNs uint64 `protobuf:"varint,2,opt,name=latency_ns,json=latencyNs,proto3" json:"latency_ns,omitempty"`
	// L7 field. This field is set if and only if FlowType is L7.
	//
	// Types that are valid to be assigned to Record:
	//	*Layer7_Dns
	//	*Layer7_Http
	//	*Layer7_Kafka
	Record               isLayer7_Record `protobuf_oneof:"record"`
	XXX_NoUnkeyedLiteral struct{}        `json:"-"`
	XXX_unrecognized     []byte          `json:"-"`
	XXX_sizecache        int32           `json:"-"`
}

func (m *Layer7) Reset()         { *m = Layer7{} }
func (m *Layer7) String() string { return proto.CompactTextString(m) }
func (*Layer7) ProtoMessage()    {}
func (*Layer7) Descriptor() ([]byte, []int) {
	return fileDescriptor_f64efb003ca9295a, []int{8}
}

func (m *Layer7) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_Layer7.Unmarshal(m, b)
}
func (m *Layer7) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_Layer7.Marshal(b, m, deterministic)
}
func (m *Layer7) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Layer7.Merge(m, src)
}
func (m *Layer7) XXX_Size() int {
	return xxx_messageInfo_Layer7.Size(m)
}
func (m *Layer7) XXX_DiscardUnknown() {
	xxx_messageInfo_Layer7.DiscardUnknown(m)
}

var xxx_messageInfo_Layer7 proto.InternalMessageInfo

func (m *Layer7) GetType() L7FlowType {
	if m != nil {
		return m.Type
	}
	return L7FlowType_UNKNOWN_L7_TYPE
}

func (m *Layer7) GetLatencyNs() uint64 {
	if m != nil {
		return m.LatencyNs
	}
	return 0
}

type isLayer7_Record interface {
	isLayer7_Record()
}

type Layer7_Dns struct {
	Dns *DNS `protobuf:"bytes,100,opt,name=dns,proto3,oneof"`
}

type Layer7_Http struct {
	Http *HTTP `protobuf:"bytes,101,opt,name=http,proto3,oneof"`
}

type Layer7_Kafka struct {
	Kafka *Kafka `protobuf:"bytes,102,opt,name=kafka,proto3,oneof"`
}

func (*Layer7_Dns) isLayer7_Record() {}

func (*Layer7_Http) isLayer7_Record() {}

func (*Layer7_Kafka) isLayer7_Record() {}

func (m *Layer7) GetRecord() isLayer7_Record {
	if m != nil {
		return m.Record
	}
	return nil
}

func (m *Layer7) GetDns() *DNS {
	if x, ok := m.GetRecord().(*Layer7_Dns); ok {
		return x.Dns
	}
	return nil
}

func (m *Layer7) GetHttp() *HTTP {
	if x, ok := m.GetRecord().(*Layer7_Http); ok {
		return x.Http
	}
	return nil
}

func (m *Layer7) GetKafka() *Kafka {
	if x, ok := m.GetRecord().(*Layer7_Kafka); ok {
		return x.Kafka
	}
	return nil
}

// XXX_OneofWrappers is for the internal use of the proto package.
func (*Layer7) XXX_OneofWrappers() []interface{} {
	return []interface{}{
		(*Layer7_Dns)(nil),
		(*Layer7_Http)(nil),
		(*Layer7_Kafka)(nil),
	}
}

type Endpoint struct {
	ID        uint64 `protobuf:"varint,1,opt,name=ID,proto3" json:"ID,omitempty"`
	Identity  uint64 `protobuf:"varint,2,opt,name=identity,proto3" json:"identity,omitempty"`
	Namespace string `protobuf:"bytes,3,opt,name=namespace,proto3" json:"namespace,omitempty"`
	// labels in `foo=bar` format.
	Labels               []string `protobuf:"bytes,4,rep,name=labels,proto3" json:"labels,omitempty"`
	PodName              string   `protobuf:"bytes,5,opt,name=pod_name,json=podName,proto3" json:"pod_name,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *Endpoint) Reset()         { *m = Endpoint{} }
func (m *Endpoint) String() string { return proto.CompactTextString(m) }
func (*Endpoint) ProtoMessage()    {}
func (*Endpoint) Descriptor() ([]byte, []int) {
	return fileDescriptor_f64efb003ca9295a, []int{9}
}

func (m *Endpoint) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_Endpoint.Unmarshal(m, b)
}
func (m *Endpoint) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_Endpoint.Marshal(b, m, deterministic)
}
func (m *Endpoint) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Endpoint.Merge(m, src)
}
func (m *Endpoint) XXX_Size() int {
	return xxx_messageInfo_Endpoint.Size(m)
}
func (m *Endpoint) XXX_DiscardUnknown() {
	xxx_messageInfo_Endpoint.DiscardUnknown(m)
}

var xxx_messageInfo_Endpoint proto.InternalMessageInfo

func (m *Endpoint) GetID() uint64 {
	if m != nil {
		return m.ID
	}
	return 0
}

func (m *Endpoint) GetIdentity() uint64 {
	if m != nil {
		return m.Identity
	}
	return 0
}

func (m *Endpoint) GetNamespace() string {
	if m != nil {
		return m.Namespace
	}
	return ""
}

func (m *Endpoint) GetLabels() []string {
	if m != nil {
		return m.Labels
	}
	return nil
}

func (m *Endpoint) GetPodName() string {
	if m != nil {
		return m.PodName
	}
	return ""
}

type TCP struct {
	SourcePort           uint32    `protobuf:"varint,1,opt,name=source_port,json=sourcePort,proto3" json:"source_port,omitempty"`
	DestinationPort      uint32    `protobuf:"varint,2,opt,name=destination_port,json=destinationPort,proto3" json:"destination_port,omitempty"`
	Flags                *TCPFlags `protobuf:"bytes,3,opt,name=flags,proto3" json:"flags,omitempty"`
	XXX_NoUnkeyedLiteral struct{}  `json:"-"`
	XXX_unrecognized     []byte    `json:"-"`
	XXX_sizecache        int32     `json:"-"`
}

func (m *TCP) Reset()         { *m = TCP{} }
func (m *TCP) String() string { return proto.CompactTextString(m) }
func (*TCP) ProtoMessage()    {}
func (*TCP) Descriptor() ([]byte, []int) {
	return fileDescriptor_f64efb003ca9295a, []int{10}
}

func (m *TCP) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_TCP.Unmarshal(m, b)
}
func (m *TCP) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_TCP.Marshal(b, m, deterministic)
}
func (m *TCP) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TCP.Merge(m, src)
}
func (m *TCP) XXX_Size() int {
	return xxx_messageInfo_TCP.Size(m)
}
func (m *TCP) XXX_DiscardUnknown() {
	xxx_messageInfo_TCP.DiscardUnknown(m)
}

var xxx_messageInfo_TCP proto.InternalMessageInfo

func (m *TCP) GetSourcePort() uint32 {
	if m != nil {
		return m.SourcePort
	}
	return 0
}

func (m *TCP) GetDestinationPort() uint32 {
	if m != nil {
		return m.DestinationPort
	}
	return 0
}

func (m *TCP) GetFlags() *TCPFlags {
	if m != nil {
		return m.Flags
	}
	return nil
}

type IP struct {
	Source      string    `protobuf:"bytes,1,opt,name=source,proto3" json:"source,omitempty"`
	Destination string    `protobuf:"bytes,2,opt,name=destination,proto3" json:"destination,omitempty"`
	IpVersion   IPVersion `protobuf:"varint,3,opt,name=ipVersion,proto3,enum=observer.IPVersion" json:"ipVersion,omitempty"`
	// This field indicates whether the TraceReasonEncryptMask is set or not.
	// https://github.com/cilium/cilium/blob/ba0ed147bd5bb342f67b1794c2ad13c6e99d5236/pkg/monitor/datapath_trace.go#L27
	Encrypted            bool     `protobuf:"varint,4,opt,name=encrypted,proto3" json:"encrypted,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *IP) Reset()         { *m = IP{} }
func (m *IP) String() string { return proto.CompactTextString(m) }
func (*IP) ProtoMessage()    {}
func (*IP) Descriptor() ([]byte, []int) {
	return fileDescriptor_f64efb003ca9295a, []int{11}
}

func (m *IP) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_IP.Unmarshal(m, b)
}
func (m *IP) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_IP.Marshal(b, m, deterministic)
}
func (m *IP) XXX_Merge(src proto.Message) {
	xxx_messageInfo_IP.Merge(m, src)
}
func (m *IP) XXX_Size() int {
	return xxx_messageInfo_IP.Size(m)
}
func (m *IP) XXX_DiscardUnknown() {
	xxx_messageInfo_IP.DiscardUnknown(m)
}

var xxx_messageInfo_IP proto.InternalMessageInfo

func (m *IP) GetSource() string {
	if m != nil {
		return m.Source
	}
	return ""
}

func (m *IP) GetDestination() string {
	if m != nil {
		return m.Destination
	}
	return ""
}

func (m *IP) GetIpVersion() IPVersion {
	if m != nil {
		return m.IpVersion
	}
	return IPVersion_IP_NOT_USED
}

func (m *IP) GetEncrypted() bool {
	if m != nil {
		return m.Encrypted
	}
	return false
}

type Ethernet struct {
	Source               string   `protobuf:"bytes,1,opt,name=source,proto3" json:"source,omitempty"`
	Destination          string   `protobuf:"bytes,2,opt,name=destination,proto3" json:"destination,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *Ethernet) Reset()         { *m = Ethernet{} }
func (m *Ethernet) String() string { return proto.CompactTextString(m) }
func (*Ethernet) ProtoMessage()    {}
func (*Ethernet) Descriptor() ([]byte, []int) {
	return fileDescriptor_f64efb003ca9295a, []int{12}
}

func (m *Ethernet) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_Ethernet.Unmarshal(m, b)
}
func (m *Ethernet) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_Ethernet.Marshal(b, m, deterministic)
}
func (m *Ethernet) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Ethernet.Merge(m, src)
}
func (m *Ethernet) XXX_Size() int {
	return xxx_messageInfo_Ethernet.Size(m)
}
func (m *Ethernet) XXX_DiscardUnknown() {
	xxx_messageInfo_Ethernet.DiscardUnknown(m)
}

var xxx_messageInfo_Ethernet proto.InternalMessageInfo

func (m *Ethernet) GetSource() string {
	if m != nil {
		return m.Source
	}
	return ""
}

func (m *Ethernet) GetDestination() string {
	if m != nil {
		return m.Destination
	}
	return ""
}

type TCPFlags struct {
	FIN                  bool     `protobuf:"varint,1,opt,name=FIN,proto3" json:"FIN,omitempty"`
	SYN                  bool     `protobuf:"varint,2,opt,name=SYN,proto3" json:"SYN,omitempty"`
	RST                  bool     `protobuf:"varint,3,opt,name=RST,proto3" json:"RST,omitempty"`
	PSH                  bool     `protobuf:"varint,4,opt,name=PSH,proto3" json:"PSH,omitempty"`
	ACK                  bool     `protobuf:"varint,5,opt,name=ACK,proto3" json:"ACK,omitempty"`
	URG                  bool     `protobuf:"varint,6,opt,name=URG,proto3" json:"URG,omitempty"`
	ECE                  bool     `protobuf:"varint,7,opt,name=ECE,proto3" json:"ECE,omitempty"`
	CWR                  bool     `protobuf:"varint,8,opt,name=CWR,proto3" json:"CWR,omitempty"`
	NS                   bool     `protobuf:"varint,9,opt,name=NS,proto3" json:"NS,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *TCPFlags) Reset()         { *m = TCPFlags{} }
func (m *TCPFlags) String() string { return proto.CompactTextString(m) }
func (*TCPFlags) ProtoMessage()    {}
func (*TCPFlags) Descriptor() ([]byte, []int) {
	return fileDescriptor_f64efb003ca9295a, []int{13}
}

func (m *TCPFlags) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_TCPFlags.Unmarshal(m, b)
}
func (m *TCPFlags) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_TCPFlags.Marshal(b, m, deterministic)
}
func (m *TCPFlags) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TCPFlags.Merge(m, src)
}
func (m *TCPFlags) XXX_Size() int {
	return xxx_messageInfo_TCPFlags.Size(m)
}
func (m *TCPFlags) XXX_DiscardUnknown() {
	xxx_messageInfo_TCPFlags.DiscardUnknown(m)
}

var xxx_messageInfo_TCPFlags proto.InternalMessageInfo

func (m *TCPFlags) GetFIN() bool {
	if m != nil {
		return m.FIN
	}
	return false
}

func (m *TCPFlags) GetSYN() bool {
	if m != nil {
		return m.SYN
	}
	return false
}

func (m *TCPFlags) GetRST() bool {
	if m != nil {
		return m.RST
	}
	return false
}

func (m *TCPFlags) GetPSH() bool {
	if m != nil {
		return m.PSH
	}
	return false
}

func (m *TCPFlags) GetACK() bool {
	if m != nil {
		return m.ACK
	}
	return false
}

func (m *TCPFlags) GetURG() bool {
	if m != nil {
		return m.URG
	}
	return false
}

func (m *TCPFlags) GetECE() bool {
	if m != nil {
		return m.ECE
	}
	return false
}

func (m *TCPFlags) GetCWR() bool {
	if m != nil {
		return m.CWR
	}
	return false
}

func (m *TCPFlags) GetNS() bool {
	if m != nil {
		return m.NS
	}
	return false
}

type UDP struct {
	SourcePort           uint32   `protobuf:"varint,1,opt,name=source_port,json=sourcePort,proto3" json:"source_port,omitempty"`
	DestinationPort      uint32   `protobuf:"varint,2,opt,name=destination_port,json=destinationPort,proto3" json:"destination_port,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *UDP) Reset()         { *m = UDP{} }
func (m *UDP) String() string { return proto.CompactTextString(m) }
func (*UDP) ProtoMessage()    {}
func (*UDP) Descriptor() ([]byte, []int) {
	return fileDescriptor_f64efb003ca9295a, []int{14}
}

func (m *UDP) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_UDP.Unmarshal(m, b)
}
func (m *UDP) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_UDP.Marshal(b, m, deterministic)
}
func (m *UDP) XXX_Merge(src proto.Message) {
	xxx_messageInfo_UDP.Merge(m, src)
}
func (m *UDP) XXX_Size() int {
	return xxx_messageInfo_UDP.Size(m)
}
func (m *UDP) XXX_DiscardUnknown() {
	xxx_messageInfo_UDP.DiscardUnknown(m)
}

var xxx_messageInfo_UDP proto.InternalMessageInfo

func (m *UDP) GetSourcePort() uint32 {
	if m != nil {
		return m.SourcePort
	}
	return 0
}

func (m *UDP) GetDestinationPort() uint32 {
	if m != nil {
		return m.DestinationPort
	}
	return 0
}

type ICMPv4 struct {
	Type                 uint32   `protobuf:"varint,1,opt,name=type,proto3" json:"type,omitempty"`
	Code                 uint32   `protobuf:"varint,2,opt,name=code,proto3" json:"code,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *ICMPv4) Reset()         { *m = ICMPv4{} }
func (m *ICMPv4) String() string { return proto.CompactTextString(m) }
func (*ICMPv4) ProtoMessage()    {}
func (*ICMPv4) Descriptor() ([]byte, []int) {
	return fileDescriptor_f64efb003ca9295a, []int{15}
}

func (m *ICMPv4) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_ICMPv4.Unmarshal(m, b)
}
func (m *ICMPv4) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_ICMPv4.Marshal(b, m, deterministic)
}
func (m *ICMPv4) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ICMPv4.Merge(m, src)
}
func (m *ICMPv4) XXX_Size() int {
	return xxx_messageInfo_ICMPv4.Size(m)
}
func (m *ICMPv4) XXX_DiscardUnknown() {
	xxx_messageInfo_ICMPv4.DiscardUnknown(m)
}

var xxx_messageInfo_ICMPv4 proto.InternalMessageInfo

func (m *ICMPv4) GetType() uint32 {
	if m != nil {
		return m.Type
	}
	return 0
}

func (m *ICMPv4) GetCode() uint32 {
	if m != nil {
		return m.Code
	}
	return 0
}

type ICMPv6 struct {
	Type                 uint32   `protobuf:"varint,1,opt,name=type,proto3" json:"type,omitempty"`
	Code                 uint32   `protobuf:"varint,2,opt,name=code,proto3" json:"code,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *ICMPv6) Reset()         { *m = ICMPv6{} }
func (m *ICMPv6) String() string { return proto.CompactTextString(m) }
func (*ICMPv6) ProtoMessage()    {}
func (*ICMPv6) Descriptor() ([]byte, []int) {
	return fileDescriptor_f64efb003ca9295a, []int{16}
}

func (m *ICMPv6) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_ICMPv6.Unmarshal(m, b)
}
func (m *ICMPv6) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_ICMPv6.Marshal(b, m, deterministic)
}
func (m *ICMPv6) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ICMPv6.Merge(m, src)
}
func (m *ICMPv6) XXX_Size() int {
	return xxx_messageInfo_ICMPv6.Size(m)
}
func (m *ICMPv6) XXX_DiscardUnknown() {
	xxx_messageInfo_ICMPv6.DiscardUnknown(m)
}

var xxx_messageInfo_ICMPv6 proto.InternalMessageInfo

func (m *ICMPv6) GetType() uint32 {
	if m != nil {
		return m.Type
	}
	return 0
}

func (m *ICMPv6) GetCode() uint32 {
	if m != nil {
		return m.Code
	}
	return 0
}

// EventTypeFilter is a filter describing a particular event type
type EventTypeFilter struct {
	// type is the primary flow type as defined by:
	// github.com/cilium/cilium/pkg/monitor/api.MessageType*
	Type int32 `protobuf:"varint,1,opt,name=type,proto3" json:"type,omitempty"`
	// match_sub_type is set to true when matching on the sub_type should
	// be done. This flag is required as 0 is a valid sub_type.
	MatchSubType bool `protobuf:"varint,2,opt,name=match_sub_type,json=matchSubType,proto3" json:"match_sub_type,omitempty"`
	// sub_type is the secondary type, e.g.
	// - github.com/cilium/cilium/pkg/monitor/api.Trace*
	SubType              int32    `protobuf:"varint,3,opt,name=sub_type,json=subType,proto3" json:"sub_type,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *EventTypeFilter) Reset()         { *m = EventTypeFilter{} }
func (m *EventTypeFilter) String() string { return proto.CompactTextString(m) }
func (*EventTypeFilter) ProtoMessage()    {}
func (*EventTypeFilter) Descriptor() ([]byte, []int) {
	return fileDescriptor_f64efb003ca9295a, []int{17}
}

func (m *EventTypeFilter) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_EventTypeFilter.Unmarshal(m, b)
}
func (m *EventTypeFilter) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_EventTypeFilter.Marshal(b, m, deterministic)
}
func (m *EventTypeFilter) XXX_Merge(src proto.Message) {
	xxx_messageInfo_EventTypeFilter.Merge(m, src)
}
func (m *EventTypeFilter) XXX_Size() int {
	return xxx_messageInfo_EventTypeFilter.Size(m)
}
func (m *EventTypeFilter) XXX_DiscardUnknown() {
	xxx_messageInfo_EventTypeFilter.DiscardUnknown(m)
}

var xxx_messageInfo_EventTypeFilter proto.InternalMessageInfo

func (m *EventTypeFilter) GetType() int32 {
	if m != nil {
		return m.Type
	}
	return 0
}

func (m *EventTypeFilter) GetMatchSubType() bool {
	if m != nil {
		return m.MatchSubType
	}
	return false
}

func (m *EventTypeFilter) GetSubType() int32 {
	if m != nil {
		return m.SubType
	}
	return 0
}

// CiliumEventType from which the flow originated
type CiliumEventType struct {
	// type of event the flow originated from, i.e.
	// github.com/cilium/cilium/pkg/monitor/api.MessageType*
	Type int32 `protobuf:"varint,1,opt,name=type,proto3" json:"type,omitempty"`
	// sub_type may indicate more details depending on type, e.g.
	// - github.com/cilium/cilium/pkg/monitor/api.Trace*
	// - github.com/cilium/cilium/pkg/monitor/api.Drop*
	SubType              int32    `protobuf:"varint,2,opt,name=sub_type,json=subType,proto3" json:"sub_type,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *CiliumEventType) Reset()         { *m = CiliumEventType{} }
func (m *CiliumEventType) String() string { return proto.CompactTextString(m) }
func (*CiliumEventType) ProtoMessage()    {}
func (*CiliumEventType) Descriptor() ([]byte, []int) {
	return fileDescriptor_f64efb003ca9295a, []int{18}
}

func (m *CiliumEventType) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_CiliumEventType.Unmarshal(m, b)
}
func (m *CiliumEventType) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_CiliumEventType.Marshal(b, m, deterministic)
}
func (m *CiliumEventType) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CiliumEventType.Merge(m, src)
}
func (m *CiliumEventType) XXX_Size() int {
	return xxx_messageInfo_CiliumEventType.Size(m)
}
func (m *CiliumEventType) XXX_DiscardUnknown() {
	xxx_messageInfo_CiliumEventType.DiscardUnknown(m)
}

var xxx_messageInfo_CiliumEventType proto.InternalMessageInfo

func (m *CiliumEventType) GetType() int32 {
	if m != nil {
		return m.Type
	}
	return 0
}

func (m *CiliumEventType) GetSubType() int32 {
	if m != nil {
		return m.SubType
	}
	return 0
}

// FlowFilter represent an individual flow filter. All fields are optional. If
// multiple fields are set, then all fields must match for the filter to match.
type FlowFilter struct {
	// source_ip filters by a list of source ips
	SourceIp []string `protobuf:"bytes,1,rep,name=source_ip,json=sourceIp,proto3" json:"source_ip,omitempty"`
	// source_pod filters by a list of source pod name prefixes, optionally
	// within a given namespace (e.g. "xwing", "kube-system/coredns-").
	// The pod name can be emitted to only filter by namespace
	// (e.g. "kube-system/")
	SourcePod []string `protobuf:"bytes,2,rep,name=source_pod,json=sourcePod,proto3" json:"source_pod,omitempty"`
	// source_fqdn filters by a list of source fully qualified domain names
	SourceFqdn []string `protobuf:"bytes,7,rep,name=source_fqdn,json=sourceFqdn,proto3" json:"source_fqdn,omitempty"`
	// source_labels filters on a list of source label selectors. Selectors
	// support the full Kubernetes label selector syntax.
	SourceLabel []string `protobuf:"bytes,10,rep,name=source_label,json=sourceLabel,proto3" json:"source_label,omitempty"`
	// destination_ip filters by a list of destination ips
	DestinationIp []string `protobuf:"bytes,3,rep,name=destination_ip,json=destinationIp,proto3" json:"destination_ip,omitempty"`
	// destination_pod filters by a list of destination pod names
	DestinationPod []string `protobuf:"bytes,4,rep,name=destination_pod,json=destinationPod,proto3" json:"destination_pod,omitempty"`
	// destination_fqdn filters by a list of destination fully qualified domain names
	DestinationFqdn []string `protobuf:"bytes,8,rep,name=destination_fqdn,json=destinationFqdn,proto3" json:"destination_fqdn,omitempty"`
	// destination_label filters on a list of destination label selectors
	DestinationLabel []string `protobuf:"bytes,11,rep,name=destination_label,json=destinationLabel,proto3" json:"destination_label,omitempty"`
	// only return Flows that were classified with a particular verdict.
	Verdict []Verdict `protobuf:"varint,5,rep,packed,name=verdict,proto3,enum=observer.Verdict" json:"verdict,omitempty"`
	// event_type is the list of event types to filter on
	EventType []*EventTypeFilter `protobuf:"bytes,6,rep,name=event_type,json=eventType,proto3" json:"event_type,omitempty"`
	// http_status_code is a list of string prefixes (e.g. "4+", "404", "5+")
	// to filter on the HTTP status code
	HttpStatusCode []string `protobuf:"bytes,9,rep,name=http_status_code,json=httpStatusCode,proto3" json:"http_status_code,omitempty"`
	// protocol filters flows by L4 or L7 protocol, e.g. (e.g. "tcp", "http")
	Protocol []string `protobuf:"bytes,12,rep,name=protocol,proto3" json:"protocol,omitempty"`
	// source_port filters flows by L4 source port
	SourcePort []string `protobuf:"bytes,13,rep,name=source_port,json=sourcePort,proto3" json:"source_port,omitempty"`
	// destination_port filters flows by L4 destination port
	DestinationPort      []string `protobuf:"bytes,14,rep,name=destination_port,json=destinationPort,proto3" json:"destination_port,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *FlowFilter) Reset()         { *m = FlowFilter{} }
func (m *FlowFilter) String() string { return proto.CompactTextString(m) }
func (*FlowFilter) ProtoMessage()    {}
func (*FlowFilter) Descriptor() ([]byte, []int) {
	return fileDescriptor_f64efb003ca9295a, []int{19}
}

func (m *FlowFilter) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_FlowFilter.Unmarshal(m, b)
}
func (m *FlowFilter) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_FlowFilter.Marshal(b, m, deterministic)
}
func (m *FlowFilter) XXX_Merge(src proto.Message) {
	xxx_messageInfo_FlowFilter.Merge(m, src)
}
func (m *FlowFilter) XXX_Size() int {
	return xxx_messageInfo_FlowFilter.Size(m)
}
func (m *FlowFilter) XXX_DiscardUnknown() {
	xxx_messageInfo_FlowFilter.DiscardUnknown(m)
}

var xxx_messageInfo_FlowFilter proto.InternalMessageInfo

func (m *FlowFilter) GetSourceIp() []string {
	if m != nil {
		return m.SourceIp
	}
	return nil
}

func (m *FlowFilter) GetSourcePod() []string {
	if m != nil {
		return m.SourcePod
	}
	return nil
}

func (m *FlowFilter) GetSourceFqdn() []string {
	if m != nil {
		return m.SourceFqdn
	}
	return nil
}

func (m *FlowFilter) GetSourceLabel() []string {
	if m != nil {
		return m.SourceLabel
	}
	return nil
}

func (m *FlowFilter) GetDestinationIp() []string {
	if m != nil {
		return m.DestinationIp
	}
	return nil
}

func (m *FlowFilter) GetDestinationPod() []string {
	if m != nil {
		return m.DestinationPod
	}
	return nil
}

func (m *FlowFilter) GetDestinationFqdn() []string {
	if m != nil {
		return m.DestinationFqdn
	}
	return nil
}

func (m *FlowFilter) GetDestinationLabel() []string {
	if m != nil {
		return m.DestinationLabel
	}
	return nil
}

func (m *FlowFilter) GetVerdict() []Verdict {
	if m != nil {
		return m.Verdict
	}
	return nil
}

func (m *FlowFilter) GetEventType() []*EventTypeFilter {
	if m != nil {
		return m.EventType
	}
	return nil
}

func (m *FlowFilter) GetHttpStatusCode() []string {
	if m != nil {
		return m.HttpStatusCode
	}
	return nil
}

func (m *FlowFilter) GetProtocol() []string {
	if m != nil {
		return m.Protocol
	}
	return nil
}

func (m *FlowFilter) GetSourcePort() []string {
	if m != nil {
		return m.SourcePort
	}
	return nil
}

func (m *FlowFilter) GetDestinationPort() []string {
	if m != nil {
		return m.DestinationPort
	}
	return nil
}

// Payload is the payload, i.e. the data the monitor returns.
type Payload struct {
	// type is the event type perf returns.
	Type EventType `protobuf:"varint,1,opt,name=type,proto3,enum=observer.EventType" json:"type,omitempty"`
	// CPU is the CPU id for this event.
	CPU int32 `protobuf:"varint,2,opt,name=CPU,proto3" json:"CPU,omitempty"`
	// lost is the number of events lost for a given CPU.
	Lost uint64 `protobuf:"varint,3,opt,name=lost,proto3" json:"lost,omitempty"`
	// data is the sample data returned by perf.
	Data []byte `protobuf:"bytes,4,opt,name=data,proto3" json:"data,omitempty"`
	// time when the event was observed
	Time *types.Timestamp `protobuf:"bytes,5,opt,name=time,proto3" json:"time,omitempty"`
	// the host name from which the payload was captured.
	HostName             string   `protobuf:"bytes,6,opt,name=host_name,json=hostName,proto3" json:"host_name,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *Payload) Reset()         { *m = Payload{} }
func (m *Payload) String() string { return proto.CompactTextString(m) }
func (*Payload) ProtoMessage()    {}
func (*Payload) Descriptor() ([]byte, []int) {
	return fileDescriptor_f64efb003ca9295a, []int{20}
}

func (m *Payload) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_Payload.Unmarshal(m, b)
}
func (m *Payload) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_Payload.Marshal(b, m, deterministic)
}
func (m *Payload) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Payload.Merge(m, src)
}
func (m *Payload) XXX_Size() int {
	return xxx_messageInfo_Payload.Size(m)
}
func (m *Payload) XXX_DiscardUnknown() {
	xxx_messageInfo_Payload.DiscardUnknown(m)
}

var xxx_messageInfo_Payload proto.InternalMessageInfo

func (m *Payload) GetType() EventType {
	if m != nil {
		return m.Type
	}
	return EventType_UNKNOWN
}

func (m *Payload) GetCPU() int32 {
	if m != nil {
		return m.CPU
	}
	return 0
}

func (m *Payload) GetLost() uint64 {
	if m != nil {
		return m.Lost
	}
	return 0
}

func (m *Payload) GetData() []byte {
	if m != nil {
		return m.Data
	}
	return nil
}

func (m *Payload) GetTime() *types.Timestamp {
	if m != nil {
		return m.Time
	}
	return nil
}

func (m *Payload) GetHostName() string {
	if m != nil {
		return m.HostName
	}
	return ""
}

// DNS flow. This is basically directly mapped from Cilium's LogRecordDNS:
//     https://github.com/cilium/cilium/blob/04f3889d627774f79e56d14ddbc165b3169e2d01/pkg/proxy/accesslog/record.go#L264
type DNS struct {
	// DNS name that's being looked up: e.g. "isovalent.com."
	Query string `protobuf:"bytes,1,opt,name=query,proto3" json:"query,omitempty"`
	// List of IP addresses in the DNS response.
	Ips []string `protobuf:"bytes,2,rep,name=ips,proto3" json:"ips,omitempty"`
	// TTL in the DNS response.
	Ttl uint32 `protobuf:"varint,3,opt,name=ttl,proto3" json:"ttl,omitempty"`
	// List of CNames in the DNS response.
	Cnames []string `protobuf:"bytes,4,rep,name=cnames,proto3" json:"cnames,omitempty"`
	// Corresponds to DNSDataSource defined in:
	//   https://github.com/cilium/cilium/blob/04f3889d627774f79e56d14ddbc165b3169e2d01/pkg/proxy/accesslog/record.go#L253
	ObservationSource string `protobuf:"bytes,5,opt,name=observation_source,json=observationSource,proto3" json:"observation_source,omitempty"`
	// Return code of the DNS request defined in:
	//   https://www.iana.org/assignments/dns-parameters/dns-parameters.xhtml#dns-parameters-6
	Rcode uint32 `protobuf:"varint,6,opt,name=rcode,proto3" json:"rcode,omitempty"`
	// String representation of qtypes defined in:
	//   https://tools.ietf.org/html/rfc1035#section-3.2.3
	Qtypes []string `protobuf:"bytes,7,rep,name=qtypes,proto3" json:"qtypes,omitempty"`
	// String representation of rrtypes defined in:
	// https://www.iana.org/assignments/dns-parameters/dns-parameters.xhtml#dns-parameters-4
	Rrtypes              []string `protobuf:"bytes,8,rep,name=rrtypes,proto3" json:"rrtypes,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *DNS) Reset()         { *m = DNS{} }
func (m *DNS) String() string { return proto.CompactTextString(m) }
func (*DNS) ProtoMessage()    {}
func (*DNS) Descriptor() ([]byte, []int) {
	return fileDescriptor_f64efb003ca9295a, []int{21}
}

func (m *DNS) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_DNS.Unmarshal(m, b)
}
func (m *DNS) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_DNS.Marshal(b, m, deterministic)
}
func (m *DNS) XXX_Merge(src proto.Message) {
	xxx_messageInfo_DNS.Merge(m, src)
}
func (m *DNS) XXX_Size() int {
	return xxx_messageInfo_DNS.Size(m)
}
func (m *DNS) XXX_DiscardUnknown() {
	xxx_messageInfo_DNS.DiscardUnknown(m)
}

var xxx_messageInfo_DNS proto.InternalMessageInfo

func (m *DNS) GetQuery() string {
	if m != nil {
		return m.Query
	}
	return ""
}

func (m *DNS) GetIps() []string {
	if m != nil {
		return m.Ips
	}
	return nil
}

func (m *DNS) GetTtl() uint32 {
	if m != nil {
		return m.Ttl
	}
	return 0
}

func (m *DNS) GetCnames() []string {
	if m != nil {
		return m.Cnames
	}
	return nil
}

func (m *DNS) GetObservationSource() string {
	if m != nil {
		return m.ObservationSource
	}
	return ""
}

func (m *DNS) GetRcode() uint32 {
	if m != nil {
		return m.Rcode
	}
	return 0
}

func (m *DNS) GetQtypes() []string {
	if m != nil {
		return m.Qtypes
	}
	return nil
}

func (m *DNS) GetRrtypes() []string {
	if m != nil {
		return m.Rrtypes
	}
	return nil
}

type HTTPHeader struct {
	Key                  string   `protobuf:"bytes,1,opt,name=key,proto3" json:"key,omitempty"`
	Value                string   `protobuf:"bytes,2,opt,name=value,proto3" json:"value,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *HTTPHeader) Reset()         { *m = HTTPHeader{} }
func (m *HTTPHeader) String() string { return proto.CompactTextString(m) }
func (*HTTPHeader) ProtoMessage()    {}
func (*HTTPHeader) Descriptor() ([]byte, []int) {
	return fileDescriptor_f64efb003ca9295a, []int{22}
}

func (m *HTTPHeader) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_HTTPHeader.Unmarshal(m, b)
}
func (m *HTTPHeader) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_HTTPHeader.Marshal(b, m, deterministic)
}
func (m *HTTPHeader) XXX_Merge(src proto.Message) {
	xxx_messageInfo_HTTPHeader.Merge(m, src)
}
func (m *HTTPHeader) XXX_Size() int {
	return xxx_messageInfo_HTTPHeader.Size(m)
}
func (m *HTTPHeader) XXX_DiscardUnknown() {
	xxx_messageInfo_HTTPHeader.DiscardUnknown(m)
}

var xxx_messageInfo_HTTPHeader proto.InternalMessageInfo

func (m *HTTPHeader) GetKey() string {
	if m != nil {
		return m.Key
	}
	return ""
}

func (m *HTTPHeader) GetValue() string {
	if m != nil {
		return m.Value
	}
	return ""
}

// L7 information for HTTP flows. It corresponds to Cilium's accesslog.LogRecordHTTP type.
//   https://github.com/cilium/cilium/blob/728c79e427438ab6f8d9375b62fccd6fed4ace3a/pkg/proxy/accesslog/record.go#L206
type HTTP struct {
	Code                 uint32        `protobuf:"varint,1,opt,name=code,proto3" json:"code,omitempty"`
	Method               string        `protobuf:"bytes,2,opt,name=method,proto3" json:"method,omitempty"`
	Url                  string        `protobuf:"bytes,3,opt,name=url,proto3" json:"url,omitempty"`
	Protocol             string        `protobuf:"bytes,4,opt,name=protocol,proto3" json:"protocol,omitempty"`
	Headers              []*HTTPHeader `protobuf:"bytes,5,rep,name=headers,proto3" json:"headers,omitempty"`
	XXX_NoUnkeyedLiteral struct{}      `json:"-"`
	XXX_unrecognized     []byte        `json:"-"`
	XXX_sizecache        int32         `json:"-"`
}

func (m *HTTP) Reset()         { *m = HTTP{} }
func (m *HTTP) String() string { return proto.CompactTextString(m) }
func (*HTTP) ProtoMessage()    {}
func (*HTTP) Descriptor() ([]byte, []int) {
	return fileDescriptor_f64efb003ca9295a, []int{23}
}

func (m *HTTP) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_HTTP.Unmarshal(m, b)
}
func (m *HTTP) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_HTTP.Marshal(b, m, deterministic)
}
func (m *HTTP) XXX_Merge(src proto.Message) {
	xxx_messageInfo_HTTP.Merge(m, src)
}
func (m *HTTP) XXX_Size() int {
	return xxx_messageInfo_HTTP.Size(m)
}
func (m *HTTP) XXX_DiscardUnknown() {
	xxx_messageInfo_HTTP.DiscardUnknown(m)
}

var xxx_messageInfo_HTTP proto.InternalMessageInfo

func (m *HTTP) GetCode() uint32 {
	if m != nil {
		return m.Code
	}
	return 0
}

func (m *HTTP) GetMethod() string {
	if m != nil {
		return m.Method
	}
	return ""
}

func (m *HTTP) GetUrl() string {
	if m != nil {
		return m.Url
	}
	return ""
}

func (m *HTTP) GetProtocol() string {
	if m != nil {
		return m.Protocol
	}
	return ""
}

func (m *HTTP) GetHeaders() []*HTTPHeader {
	if m != nil {
		return m.Headers
	}
	return nil
}

// L7 information for Kafka flows. It corresponds to Cilium's accesslog.LogRecordKafka type.
//   https://github.com/cilium/cilium/blob/728c79e427438ab6f8d9375b62fccd6fed4ace3a/pkg/proxy/accesslog/record.go#L229
type Kafka struct {
	ErrorCode            int32    `protobuf:"varint,1,opt,name=error_code,json=errorCode,proto3" json:"error_code,omitempty"`
	ApiVersion           int32    `protobuf:"varint,2,opt,name=api_version,json=apiVersion,proto3" json:"api_version,omitempty"`
	ApiKey               string   `protobuf:"bytes,3,opt,name=api_key,json=apiKey,proto3" json:"api_key,omitempty"`
	CorrelationId        int32    `protobuf:"varint,4,opt,name=correlation_id,json=correlationId,proto3" json:"correlation_id,omitempty"`
	Topic                string   `protobuf:"bytes,5,opt,name=topic,proto3" json:"topic,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *Kafka) Reset()         { *m = Kafka{} }
func (m *Kafka) String() string { return proto.CompactTextString(m) }
func (*Kafka) ProtoMessage()    {}
func (*Kafka) Descriptor() ([]byte, []int) {
	return fileDescriptor_f64efb003ca9295a, []int{24}
}

func (m *Kafka) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_Kafka.Unmarshal(m, b)
}
func (m *Kafka) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_Kafka.Marshal(b, m, deterministic)
}
func (m *Kafka) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Kafka.Merge(m, src)
}
func (m *Kafka) XXX_Size() int {
	return xxx_messageInfo_Kafka.Size(m)
}
func (m *Kafka) XXX_DiscardUnknown() {
	xxx_messageInfo_Kafka.DiscardUnknown(m)
}

var xxx_messageInfo_Kafka proto.InternalMessageInfo

func (m *Kafka) GetErrorCode() int32 {
	if m != nil {
		return m.ErrorCode
	}
	return 0
}

func (m *Kafka) GetApiVersion() int32 {
	if m != nil {
		return m.ApiVersion
	}
	return 0
}

func (m *Kafka) GetApiKey() string {
	if m != nil {
		return m.ApiKey
	}
	return ""
}

func (m *Kafka) GetCorrelationId() int32 {
	if m != nil {
		return m.CorrelationId
	}
	return 0
}

func (m *Kafka) GetTopic() string {
	if m != nil {
		return m.Topic
	}
	return ""
}

type Service struct {
	Name                 string   `protobuf:"bytes,1,opt,name=name,proto3" json:"name,omitempty"`
	Namespace            string   `protobuf:"bytes,2,opt,name=namespace,proto3" json:"namespace,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *Service) Reset()         { *m = Service{} }
func (m *Service) String() string { return proto.CompactTextString(m) }
func (*Service) ProtoMessage()    {}
func (*Service) Descriptor() ([]byte, []int) {
	return fileDescriptor_f64efb003ca9295a, []int{25}
}

func (m *Service) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_Service.Unmarshal(m, b)
}
func (m *Service) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_Service.Marshal(b, m, deterministic)
}
func (m *Service) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Service.Merge(m, src)
}
func (m *Service) XXX_Size() int {
	return xxx_messageInfo_Service.Size(m)
}
func (m *Service) XXX_DiscardUnknown() {
	xxx_messageInfo_Service.DiscardUnknown(m)
}

var xxx_messageInfo_Service proto.InternalMessageInfo

func (m *Service) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *Service) GetNamespace() string {
	if m != nil {
		return m.Namespace
	}
	return ""
}

func init() {
	proto.RegisterEnum("observer.ProtocolMessageType", ProtocolMessageType_name, ProtocolMessageType_value)
	proto.RegisterEnum("observer.FlowType", FlowType_name, FlowType_value)
	proto.RegisterEnum("observer.L7FlowType", L7FlowType_name, L7FlowType_value)
	proto.RegisterEnum("observer.IPVersion", IPVersion_name, IPVersion_value)
	proto.RegisterEnum("observer.Verdict", Verdict_name, Verdict_value)
	proto.RegisterEnum("observer.EventType", EventType_name, EventType_value)
	proto.RegisterType((*ServerStatusRequest)(nil), "observer.ServerStatusRequest")
	proto.RegisterType((*ServerStatusResponse)(nil), "observer.ServerStatusResponse")
	proto.RegisterType((*GetFlowsRequest)(nil), "observer.GetFlowsRequest")
	proto.RegisterType((*GetFlowsResponse)(nil), "observer.GetFlowsResponse")
	proto.RegisterType((*ProtocolMessage)(nil), "observer.ProtocolMessage")
	proto.RegisterType((*ProtocolMessageInfo)(nil), "observer.ProtocolMessageInfo")
	proto.RegisterType((*Flow)(nil), "observer.Flow")
	proto.RegisterType((*Layer4)(nil), "observer.Layer4")
	proto.RegisterType((*Layer7)(nil), "observer.Layer7")
	proto.RegisterType((*Endpoint)(nil), "observer.Endpoint")
	proto.RegisterType((*TCP)(nil), "observer.TCP")
	proto.RegisterType((*IP)(nil), "observer.IP")
	proto.RegisterType((*Ethernet)(nil), "observer.Ethernet")
	proto.RegisterType((*TCPFlags)(nil), "observer.TCPFlags")
	proto.RegisterType((*UDP)(nil), "observer.UDP")
	proto.RegisterType((*ICMPv4)(nil), "observer.ICMPv4")
	proto.RegisterType((*ICMPv6)(nil), "observer.ICMPv6")
	proto.RegisterType((*EventTypeFilter)(nil), "observer.EventTypeFilter")
	proto.RegisterType((*CiliumEventType)(nil), "observer.CiliumEventType")
	proto.RegisterType((*FlowFilter)(nil), "observer.FlowFilter")
	proto.RegisterType((*Payload)(nil), "observer.Payload")
	proto.RegisterType((*DNS)(nil), "observer.DNS")
	proto.RegisterType((*HTTPHeader)(nil), "observer.HTTPHeader")
	proto.RegisterType((*HTTP)(nil), "observer.HTTP")
	proto.RegisterType((*Kafka)(nil), "observer.Kafka")
	proto.RegisterType((*Service)(nil), "observer.Service")
}

func init() { proto.RegisterFile("observer.proto", fileDescriptor_f64efb003ca9295a) }

var fileDescriptor_f64efb003ca9295a = []byte{
	// 2132 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xac, 0x58, 0x5f, 0x6f, 0xdb, 0xc8,
	0x11, 0x37, 0x69, 0xfd, 0xa1, 0x46, 0xb6, 0xac, 0xac, 0x73, 0x2d, 0xe3, 0x5c, 0x12, 0x87, 0xbd,
	0xf6, 0x5c, 0x07, 0x75, 0x72, 0x8e, 0x11, 0x5f, 0xaf, 0x2f, 0x8d, 0x2d, 0x39, 0x16, 0x62, 0x4b,
	0xbc, 0xa5, 0x9c, 0xe0, 0xfa, 0x22, 0xd0, 0xe2, 0xda, 0x26, 0x42, 0x91, 0x0c, 0x49, 0x39, 0x67,
	0x14, 0x7d, 0xee, 0x53, 0xd1, 0x7e, 0x81, 0x02, 0x45, 0x9f, 0x8a, 0x02, 0x7d, 0xb9, 0xb7, 0x7e,
	0x88, 0xf6, 0xad, 0xdf, 0xa1, 0xfd, 0x16, 0xc5, 0xcc, 0x2e, 0x25, 0x4a, 0xb1, 0x73, 0x41, 0xd1,
	0x17, 0x61, 0x76, 0xe6, 0x37, 0xbb, 0xb3, 0xb3, 0xf3, 0x8f, 0x82, 0x46, 0x74, 0x9a, 0x8a, 0xe4,
	0x52, 0x24, 0x5b, 0x71, 0x12, 0x65, 0x11, 0x33, 0xf2, 0xf5, 0xda, 0x83, 0xf3, 0x28, 0x3a, 0x0f,
	0xc4, 0x63, 0xe2, 0x9f, 0x8e, 0xcf, 0x1e, 0x67, 0xfe, 0x48, 0xa4, 0x99, 0x3b, 0x8a, 0x25, 0xd4,
	0xfa, 0x04, 0x56, 0x1d, 0x82, 0x3a, 0x99, 0x9b, 0x8d, 0x53, 0x2e, 0xde, 0x8e, 0x45, 0x9a, 0x59,
	0x36, 0xdc, 0x9e, 0x65, 0xa7, 0x71, 0x14, 0xa6, 0x82, 0xdd, 0x85, 0x5a, 0x38, 0x1e, 0x0d, 0xce,
	0x82, 0xe8, 0x5d, 0x6a, 0x6a, 0xeb, 0xda, 0x46, 0x89, 0x1b, 0xe1, 0x78, 0x74, 0x80, 0x6b, 0x14,
	0x8e, 0xdc, 0x6f, 0x95, 0x50, 0x97, 0xc2, 0x91, 0xfb, 0x2d, 0x09, 0xad, 0xef, 0x74, 0x58, 0x79,
	0x21, 0x32, 0x5a, 0xa8, 0x53, 0xd8, 0x0f, 0xa0, 0x12, 0x8e, 0x47, 0xa7, 0x22, 0x51, 0x5b, 0xa9,
	0x15, 0xf2, 0xcf, 0xa2, 0x20, 0x88, 0xde, 0x99, 0x8b, 0xeb, 0xda, 0x86, 0xc1, 0xd5, 0x8a, 0x6d,
	0x43, 0xed, 0x34, 0x70, 0x87, 0x6f, 0x02, 0x3f, 0xcd, 0xcc, 0xf2, 0xfa, 0xe2, 0x46, 0x7d, 0xfb,
	0xf6, 0xd6, 0xe4, 0xee, 0xb8, 0xf5, 0x81, 0x1f, 0x64, 0x22, 0xe1, 0x53, 0x18, 0xea, 0xbc, 0xbb,
	0xf0, 0x33, 0x41, 0x3a, 0x95, 0x0f, 0xe9, 0x4c, 0x60, 0xec, 0x09, 0x94, 0x53, 0x3f, 0x1c, 0x0a,
	0xb3, 0xba, 0xae, 0x6d, 0xd4, 0xb7, 0xd7, 0xb6, 0xa4, 0x17, 0xb7, 0x72, 0x2f, 0x6e, 0xf5, 0x73,
	0x2f, 0x72, 0x09, 0x44, 0x8d, 0x71, 0x98, 0xf9, 0x81, 0x69, 0x7c, 0xbf, 0x06, 0x01, 0xd9, 0x8f,
	0x60, 0x39, 0x7d, 0xe3, 0xc7, 0x03, 0x4f, 0x0c, 0x23, 0xcf, 0x0f, 0xcf, 0xcd, 0x1a, 0x5d, 0x75,
	0x09, 0x99, 0x2d, 0xc5, 0xb3, 0xfe, 0xa5, 0x41, 0x73, 0xea, 0x34, 0xf5, 0x06, 0x9f, 0x41, 0x09,
	0x5d, 0x4c, 0x3e, 0xab, 0x6f, 0x37, 0x66, 0x2f, 0x73, 0xb8, 0xc0, 0x49, 0xca, 0xbe, 0x02, 0x90,
	0xec, 0xc1, 0x28, 0x3d, 0xa7, 0xd7, 0xa8, 0x6f, 0xdf, 0x99, 0x62, 0x6d, 0x34, 0x6c, 0x18, 0x05,
	0xc7, 0x22, 0x4d, 0xdd, 0x73, 0x71, 0xb8, 0xc0, 0x6b, 0x52, 0x72, 0x9c, 0x9e, 0xb3, 0x4f, 0xa1,
	0x16, 0x46, 0x9e, 0x18, 0x84, 0xee, 0x48, 0x98, 0xff, 0x46, 0x27, 0xd4, 0xb8, 0x81, 0x9c, 0xae,
	0x3b, 0x12, 0xec, 0x31, 0x94, 0x30, 0x8a, 0xcc, 0xff, 0x7c, 0xbf, 0x77, 0x08, 0xb8, 0xd7, 0x84,
	0x46, 0xa2, 0x8c, 0x1f, 0x64, 0x57, 0xb1, 0x48, 0xad, 0x63, 0x58, 0x99, 0x33, 0x80, 0x3d, 0x85,
	0x92, 0x1f, 0x9e, 0x45, 0xea, 0x56, 0xf7, 0x6e, 0xb4, 0xb4, 0x13, 0x9e, 0x45, 0x78, 0x49, 0x04,
	0xef, 0x95, 0x61, 0x71, 0x94, 0x9e, 0x5b, 0xbf, 0x82, 0xd5, 0x6b, 0x50, 0xac, 0x49, 0x52, 0xda,
	0xb1, 0xc6, 0x91, 0x64, 0x5f, 0x40, 0x09, 0x0d, 0x20, 0x77, 0x34, 0x3e, 0x70, 0x48, 0xff, 0x2a,
	0x16, 0x9c, 0xa0, 0xd6, 0x5f, 0x2a, 0x50, 0x42, 0xc7, 0xb2, 0x2d, 0x75, 0x6d, 0xed, 0xe3, 0x6e,
	0xcd, 0x1e, 0x41, 0xf5, 0x52, 0x24, 0x9e, 0x3f, 0xcc, 0xd4, 0x71, 0xb7, 0xa6, 0xc7, 0xbd, 0x92,
	0x02, 0x9e, 0x23, 0xd8, 0x03, 0xa8, 0x7b, 0x49, 0x14, 0x0f, 0x12, 0xe1, 0xa6, 0x51, 0x48, 0x61,
	0xbf, 0xcc, 0x01, 0x59, 0x9c, 0x38, 0x6c, 0x0b, 0x0c, 0x91, 0x5d, 0x88, 0x24, 0x14, 0x99, 0x59,
	0x22, 0x0b, 0xd8, 0x74, 0xbb, 0xb6, 0x92, 0xf0, 0x09, 0x86, 0x7d, 0x0a, 0x7a, 0xc7, 0x36, 0xcb,
	0x84, 0x5c, 0x9a, 0x22, 0x3b, 0x36, 0xd7, 0x3b, 0x36, 0x5b, 0x07, 0x3d, 0xd8, 0x31, 0x2b, 0x24,
	0x6d, 0x4e, 0xa5, 0x47, 0xee, 0x95, 0x48, 0x76, 0xb8, 0x1e, 0xec, 0xb0, 0x4d, 0xa8, 0xa4, 0xd1,
	0x38, 0x19, 0x0a, 0x15, 0xd1, 0xc5, 0xd3, 0x42, 0x2f, 0x8e, 0xfc, 0x30, 0xe3, 0x0a, 0xc1, 0x76,
	0xa0, 0xee, 0x89, 0x34, 0xf3, 0x43, 0x37, 0xf3, 0xa3, 0x90, 0x02, 0xf9, 0x7a, 0x85, 0x22, 0x8c,
	0xfd, 0x04, 0x4a, 0xe8, 0x66, 0x13, 0xc8, 0x39, 0x6c, 0x36, 0x8c, 0xe5, 0x03, 0xe0, 0x2f, 0x95,
	0x9c, 0x49, 0x30, 0xd6, 0xe7, 0x62, 0xf1, 0x11, 0x54, 0x63, 0xf7, 0x2a, 0x88, 0x5c, 0xcf, 0x5c,
	0xa2, 0x63, 0x0b, 0x4e, 0xb6, 0xa5, 0x80, 0xe7, 0x08, 0xf6, 0x10, 0x96, 0xa4, 0xc5, 0xb4, 0x57,
	0x6a, 0x2e, 0xaf, 0x2f, 0x6e, 0xd4, 0x78, 0x5d, 0xf2, 0x70, 0xbb, 0x94, 0x3d, 0x82, 0x5b, 0x05,
	0x1b, 0x15, 0xae, 0x41, 0xb8, 0x66, 0x41, 0x20, 0xc1, 0xe8, 0xc5, 0x5d, 0x73, 0xe5, 0x5a, 0x2f,
	0xee, 0x72, 0x3d, 0xd8, 0x65, 0xb7, 0xa1, 0x9c, 0x88, 0x38, 0xb8, 0x32, 0x9b, 0x94, 0xdc, 0x72,
	0xc1, 0xbe, 0x04, 0x10, 0x97, 0x22, 0xcc, 0x28, 0x19, 0xcc, 0xd5, 0xf9, 0xd4, 0xdc, 0xf7, 0x03,
	0x7f, 0x3c, 0x6a, 0x23, 0x82, 0xdc, 0x50, 0x13, 0x39, 0xc9, 0xbe, 0x84, 0x86, 0xba, 0x01, 0x62,
	0xfd, 0xa1, 0x30, 0x6f, 0xcf, 0xdf, 0xda, 0x91, 0x02, 0xbe, 0x2c, 0x81, 0x6a, 0xc9, 0xf6, 0x60,
	0xb5, 0x78, 0xb1, 0x5c, 0xfd, 0x93, 0x9b, 0xd4, 0x59, 0x01, 0x9d, 0xef, 0x71, 0x1f, 0xaa, 0xce,
	0x78, 0x34, 0x72, 0x93, 0x2b, 0xf3, 0x4f, 0xbf, 0xc3, 0xe0, 0xa9, 0xed, 0xe9, 0xa6, 0xc6, 0x73,
	0xa6, 0xf5, 0x9d, 0x06, 0x15, 0x19, 0x42, 0xec, 0x21, 0x2c, 0xf6, 0xf7, 0x6d, 0x95, 0x2b, 0xcb,
	0xd3, 0xed, 0xfb, 0xfb, 0xf6, 0xe1, 0x02, 0x47, 0x19, 0x42, 0x4e, 0x5a, 0xb6, 0xaa, 0x4c, 0x05,
	0xc8, 0x49, 0x8b, 0x20, 0x27, 0x2d, 0x1b, 0x83, 0xb0, 0xb3, 0x7f, 0x6c, 0x5f, 0xee, 0x50, 0x42,
	0xcc, 0x38, 0x59, 0xf2, 0x0f, 0x17, 0xb8, 0x42, 0x4c, 0xb0, 0xcf, 0x54, 0x7a, 0xcc, 0x63, 0x9f,
	0x4d, 0xb0, 0xcf, 0xf6, 0x00, 0x8c, 0x58, 0x25, 0xbc, 0xf5, 0x8f, 0xdc, 0xe8, 0x5d, 0xb6, 0xa1,
	0xaa, 0x83, 0x46, 0x11, 0x59, 0xe8, 0x12, 0x47, 0xbb, 0xd3, 0x98, 0x44, 0x04, 0xbb, 0x07, 0x10,
	0xb8, 0x99, 0x08, 0x87, 0x57, 0x83, 0x30, 0x6f, 0x75, 0x35, 0xc5, 0xe9, 0xa6, 0x78, 0x35, 0x2f,
	0x4c, 0x4d, 0x6f, 0xfe, 0x6a, 0xad, 0xae, 0x83, 0x57, 0xf3, 0xc2, 0x14, 0x8b, 0xf8, 0x45, 0x96,
	0xc5, 0xa6, 0x98, 0x2f, 0xe2, 0x87, 0xfd, 0x3e, 0xde, 0x9f, 0xa4, 0xec, 0x73, 0x28, 0xbf, 0x71,
	0xcf, 0xde, 0xb8, 0xe6, 0x19, 0xc1, 0x56, 0xa6, 0xb0, 0x97, 0xc8, 0x3e, 0x5c, 0xe0, 0x52, 0xbe,
	0x67, 0x40, 0x25, 0x11, 0xc3, 0x28, 0xf1, 0xac, 0xdf, 0x6a, 0x60, 0xe4, 0x09, 0xc7, 0x1a, 0xa0,
	0x77, 0x5a, 0xaa, 0xb9, 0xea, 0x9d, 0x16, 0x5b, 0x03, 0xc3, 0xf7, 0x44, 0x98, 0xf9, 0xd9, 0x55,
	0xde, 0xa0, 0xf3, 0x35, 0x15, 0x7d, 0x0c, 0xeb, 0xd8, 0x1d, 0x0a, 0xf2, 0x77, 0x8d, 0x4f, 0x19,
	0xd8, 0x92, 0x03, 0xf7, 0x54, 0x04, 0xa9, 0x59, 0xa2, 0x6c, 0x50, 0x2b, 0x76, 0x07, 0x8c, 0x38,
	0xf2, 0x64, 0x72, 0x96, 0x49, 0xa9, 0x1a, 0x47, 0x1e, 0xe6, 0x87, 0xf5, 0x6b, 0x8a, 0x01, 0x2c,
	0x6d, 0x2a, 0x66, 0xe3, 0x28, 0xc9, 0xc8, 0x98, 0x65, 0x0e, 0x92, 0x65, 0x47, 0x49, 0xc6, 0x7e,
	0x0a, 0xc5, 0xd4, 0x92, 0x28, 0x9d, 0x50, 0x2b, 0x05, 0x3e, 0x41, 0x37, 0xa0, 0x7c, 0x16, 0xb8,
	0xe7, 0xa9, 0x8a, 0x07, 0x36, 0x13, 0x58, 0x07, 0x28, 0xe1, 0x12, 0x60, 0xfd, 0x5e, 0xc3, 0x02,
	0x88, 0x66, 0xab, 0x32, 0x26, 0xbb, 0x40, 0x5e, 0xb2, 0xd6, 0x67, 0x4b, 0x96, 0x4e, 0xc2, 0x99,
	0xf2, 0xf4, 0x05, 0xd4, 0xfc, 0xf8, 0x95, 0x48, 0x52, 0x5f, 0xd5, 0xe3, 0xc6, 0xf6, 0x6a, 0xb1,
	0x8e, 0x2a, 0x11, 0x9f, 0xa2, 0xd0, 0x83, 0x22, 0x1c, 0x26, 0x57, 0x71, 0x26, 0x3c, 0x8a, 0x42,
	0x83, 0x4f, 0x19, 0x56, 0x0b, 0x8c, 0xbc, 0x4e, 0xff, 0xef, 0x66, 0x59, 0x7f, 0xd5, 0xc0, 0xc8,
	0xef, 0x8a, 0x0d, 0xee, 0xa0, 0xd3, 0xa5, 0x3d, 0x0c, 0x8e, 0x24, 0x72, 0x9c, 0x6f, 0xba, 0xa4,
	0x68, 0x70, 0x24, 0x91, 0xc3, 0x9d, 0xbe, 0x1a, 0xa4, 0x90, 0x44, 0x8e, 0xed, 0x1c, 0x2a, 0x03,
	0x91, 0x44, 0xce, 0xf3, 0xfd, 0x97, 0xf4, 0x7e, 0x06, 0x47, 0x12, 0x39, 0x27, 0xfc, 0x05, 0x75,
	0x08, 0x83, 0x23, 0x89, 0x9c, 0xf6, 0x7e, 0x9b, 0x26, 0x22, 0x83, 0x23, 0x89, 0x9c, 0xfd, 0xd7,
	0x9c, 0xfa, 0x83, 0xc1, 0x91, 0xc4, 0x70, 0xeb, 0x3a, 0x6a, 0x90, 0xd1, 0xbb, 0x8e, 0xf5, 0x35,
	0xa5, 0xf8, 0xff, 0x33, 0x02, 0xac, 0x27, 0x79, 0x49, 0x60, 0xac, 0x90, 0xad, 0xcb, 0x2a, 0x2f,
	0x19, 0x94, 0x86, 0x91, 0x27, 0x94, 0x32, 0xd1, 0x13, 0x8d, 0x67, 0x1f, 0xad, 0x71, 0x06, 0x2b,
	0x93, 0xea, 0x2b, 0x87, 0xc3, 0x19, 0xd5, 0xb2, 0x52, 0xfd, 0x0c, 0x1a, 0x23, 0x37, 0x1b, 0x5e,
	0x0c, 0xd2, 0xf1, 0xe9, 0x60, 0x32, 0x56, 0x18, 0x7c, 0x89, 0xb8, 0xce, 0xf8, 0x94, 0x4a, 0xf6,
	0x1d, 0x30, 0x26, 0xf2, 0x45, 0xd2, 0xae, 0xa6, 0x52, 0x64, 0xfd, 0x12, 0x56, 0xe6, 0x6a, 0xfd,
	0xb5, 0xe7, 0x14, 0x77, 0xd0, 0x67, 0x77, 0xf8, 0x5b, 0x09, 0x60, 0x3a, 0xc2, 0x62, 0xab, 0x54,
	0x8e, 0xf6, 0x63, 0x53, 0xa3, 0x3c, 0x35, 0x24, 0xa3, 0x13, 0x63, 0xcd, 0x9a, 0xbc, 0x82, 0x67,
	0xea, 0x24, 0xad, 0xe5, 0x8f, 0xe0, 0x15, 0x1e, 0xe9, 0xec, 0xad, 0x17, 0x9a, 0x55, 0x92, 0x2b,
	0x8d, 0x83, 0xb7, 0x5e, 0x58, 0xe8, 0x9e, 0x94, 0xfa, 0x26, 0x14, 0xbb, 0xe7, 0x11, 0xb2, 0xd8,
	0x8f, 0xa1, 0x51, 0x7c, 0x47, 0x3f, 0x36, 0x17, 0x09, 0xb4, 0x5c, 0xe0, 0x76, 0xb0, 0xaa, 0xad,
	0xcc, 0x3e, 0xb7, 0xa7, 0x8a, 0x4a, 0x63, 0xe6, 0xb5, 0xbd, 0xf9, 0xb8, 0x20, 0xc3, 0x0c, 0x42,
	0x16, 0x37, 0x20, 0xeb, 0xe6, 0x1a, 0xb7, 0x34, 0xb1, 0xfe, 0x5e, 0xe3, 0x96, 0x76, 0x16, 0x46,
	0x33, 0xfc, 0x8a, 0xf8, 0xf0, 0x68, 0x36, 0xdb, 0xad, 0xe5, 0x17, 0x44, 0xa1, 0x5b, 0xcf, 0x45,
	0x4a, 0xb1, 0x5b, 0x6f, 0x40, 0x13, 0xab, 0xf8, 0x20, 0xa5, 0x6f, 0xa8, 0x01, 0xc5, 0x59, 0x4d,
	0x5e, 0x14, 0xf9, 0xf2, 0xd3, 0x6a, 0x3f, 0xf2, 0x04, 0xd6, 0xe5, 0xbc, 0x21, 0x99, 0x4b, 0xf2,
	0xdd, 0xf2, 0xf5, 0x7c, 0xf6, 0x2c, 0x17, 0x1f, 0xe6, 0xc6, 0xec, 0x69, 0xbc, 0xe7, 0x25, 0xca,
	0x9e, 0xbf, 0x6b, 0x50, 0x55, 0x63, 0x11, 0xfb, 0x7c, 0xa6, 0xdb, 0xad, 0x5e, 0x73, 0x23, 0x15,
	0x7f, 0x98, 0xe7, 0xf6, 0x89, 0x0a, 0x3d, 0x24, 0x31, 0x4a, 0x83, 0x28, 0xcd, 0x28, 0x9e, 0x4b,
	0x9c, 0x68, 0xe4, 0x79, 0x6e, 0xe6, 0x52, 0x59, 0x59, 0xe2, 0x44, 0x4f, 0x46, 0xe6, 0xf2, 0x47,
	0x8e, 0xcc, 0x77, 0xa1, 0x76, 0x11, 0xa5, 0x99, 0xec, 0x26, 0x15, 0x39, 0xea, 0x21, 0x83, 0xda,
	0xc9, 0x3f, 0x35, 0x58, 0x6c, 0x75, 0x1d, 0x9c, 0xa9, 0xde, 0x8e, 0x45, 0x72, 0xa5, 0x4a, 0xa7,
	0x5c, 0xa0, 0x91, 0x7e, 0x9c, 0xaa, 0xb0, 0x46, 0x12, 0x39, 0x59, 0x16, 0xa8, 0x51, 0x1a, 0x49,
	0xac, 0xba, 0x43, 0x39, 0xd1, 0xa9, 0x1e, 0x26, 0x57, 0xec, 0x67, 0xc0, 0xe4, 0xe5, 0xd5, 0x6c,
	0x24, 0x2b, 0xb3, 0xec, 0x66, 0xb7, 0x0a, 0x12, 0x47, 0x16, 0x69, 0x1c, 0xea, 0xe8, 0x2d, 0x2b,
	0xb4, 0xb5, 0x5c, 0xe0, 0xe6, 0x6f, 0xe9, 0xe3, 0x46, 0xa5, 0x8e, 0x5a, 0x31, 0x13, 0xaa, 0x49,
	0x22, 0x05, 0x32, 0x74, 0xf3, 0xa5, 0xb5, 0x03, 0x40, 0xcd, 0x5e, 0xb8, 0x9e, 0x48, 0xd0, 0xdc,
	0x37, 0x22, 0xbf, 0x14, 0x92, 0x78, 0xce, 0xa5, 0x1b, 0x8c, 0x85, 0x6a, 0x03, 0x72, 0x61, 0xfd,
	0x41, 0x83, 0x12, 0xaa, 0x4d, 0x2a, 0x97, 0x36, 0xad, 0x5c, 0x68, 0xc4, 0x48, 0x64, 0x17, 0x94,
	0xdf, 0xd4, 0x57, 0xe4, 0x0a, 0x37, 0x1f, 0x27, 0x81, 0xea, 0xea, 0x48, 0xce, 0x44, 0x5c, 0x49,
	0x7a, 0x7a, 0x12, 0x71, 0x5b, 0x50, 0xbd, 0x20, 0xa3, 0xd2, 0xf7, 0x3f, 0xb2, 0xa7, 0x16, 0xf3,
	0x1c, 0x64, 0xfd, 0x51, 0x83, 0x32, 0xcd, 0x23, 0x58, 0x63, 0x44, 0x92, 0x44, 0xc9, 0x60, 0x62,
	0x59, 0x99, 0xd7, 0x88, 0x43, 0x61, 0xfe, 0x00, 0xea, 0x6e, 0xec, 0x0f, 0x2e, 0x55, 0x57, 0x95,
	0x11, 0x05, 0x6e, 0xec, 0xe7, 0x1d, 0xf4, 0x87, 0x50, 0x45, 0x00, 0x3a, 0x42, 0xda, 0x5a, 0x71,
	0x63, 0xff, 0xa5, 0xb8, 0xc2, 0xca, 0x32, 0x8c, 0x92, 0x44, 0x04, 0xaa, 0xb2, 0xc8, 0xfe, 0x5a,
	0xe6, 0xcb, 0x05, 0x6e, 0xc7, 0x43, 0x97, 0x65, 0x51, 0xec, 0x0f, 0xd5, 0xe3, 0xc9, 0x85, 0xf5,
	0x0b, 0xa8, 0xe6, 0x23, 0x2c, 0x83, 0x12, 0x05, 0x97, 0x74, 0x33, 0xd1, 0xb3, 0x83, 0x8f, 0x3e,
	0x37, 0xf8, 0x6c, 0xfe, 0xe6, 0xbd, 0x6f, 0x4b, 0xca, 0xed, 0x87, 0x70, 0xef, 0xa4, 0xfb, 0xb2,
	0xdb, 0x7b, 0xdd, 0x1d, 0xd8, 0xbc, 0xd7, 0xef, 0xed, 0xf7, 0x8e, 0x06, 0xc7, 0x6d, 0xc7, 0x79,
	0xfe, 0xa2, 0x3d, 0xe8, 0x7f, 0x63, 0xb7, 0x9b, 0x0b, 0xcc, 0x82, 0xfb, 0x36, 0xef, 0xbd, 0xe0,
	0x6d, 0xc7, 0xb9, 0x01, 0xa3, 0xb1, 0x07, 0x70, 0xb7, 0xcd, 0x79, 0x8f, 0xdf, 0x00, 0xd0, 0x37,
	0x1f, 0x83, 0x91, 0xcf, 0x9e, 0xac, 0x09, 0x4b, 0xf9, 0x99, 0xea, 0x88, 0x1a, 0x94, 0x8f, 0x9e,
	0x0e, 0x8e, 0x76, 0x9a, 0x1a, 0xab, 0x80, 0x7e, 0xb4, 0xdb, 0xd4, 0x37, 0x0f, 0x01, 0xa6, 0xe3,
	0x2a, 0x5b, 0x85, 0x95, 0x5c, 0xe5, 0x68, 0x37, 0xd7, 0xaa, 0x43, 0x95, 0xb7, 0xbf, 0x3e, 0x69,
	0x3b, 0xfd, 0xa6, 0xc6, 0x96, 0xc0, 0xe0, 0x6d, 0xc7, 0xee, 0x75, 0x9d, 0x76, 0x53, 0x67, 0x00,
	0x15, 0xe7, 0xf9, 0xb1, 0x7d, 0xd4, 0x6e, 0x2e, 0x6e, 0x3e, 0x81, 0xda, 0x64, 0xcc, 0x61, 0x2b,
	0x50, 0xef, 0xd8, 0x83, 0x6e, 0xaf, 0x3f, 0x38, 0x71, 0xda, 0xad, 0xe6, 0x02, 0x33, 0xa0, 0xd4,
	0xb1, 0x2f, 0xf1, 0x64, 0x49, 0x3d, 0x6b, 0xea, 0x9b, 0x5f, 0x41, 0x55, 0x95, 0x4f, 0x3c, 0xf8,
	0x55, 0x9b, 0xb7, 0x3a, 0xfb, 0xfd, 0x81, 0x32, 0xa0, 0xb9, 0xc0, 0x96, 0xa1, 0x76, 0xd0, 0xe3,
	0xaf, 0x9f, 0xf3, 0x56, 0xbb, 0xd5, 0xd4, 0xd0, 0x8e, 0x16, 0xef, 0xd9, 0x76, 0xbb, 0xd5, 0xd4,
	0x37, 0x7f, 0x0e, 0xb5, 0x69, 0x1b, 0xac, 0x43, 0x75, 0xaa, 0xb5, 0x02, 0x75, 0x92, 0x38, 0xee,
	0x28, 0x0e, 0x44, 0xb3, 0xc6, 0x1a, 0x00, 0x9c, 0x86, 0xdd, 0xa3, 0x28, 0xcd, 0x9a, 0xfa, 0xf6,
	0x9f, 0x35, 0x30, 0x7a, 0x2a, 0x40, 0x59, 0x1b, 0x8c, 0xfc, 0x1f, 0x13, 0x56, 0x28, 0xd3, 0x73,
	0x7f, 0x3d, 0xad, 0xad, 0x5d, 0x27, 0x92, 0xff, 0x51, 0x58, 0x0b, 0x4f, 0x34, 0xd6, 0x83, 0xa5,
	0xe2, 0x1f, 0x60, 0xec, 0xde, 0xec, 0x27, 0xd2, 0xdc, 0xff, 0x65, 0x6b, 0xf7, 0x6f, 0x12, 0xe7,
	0x5b, 0x9e, 0x56, 0x28, 0xbd, 0x9e, 0xfe, 0x37, 0x00, 0x00, 0xff, 0xff, 0xe1, 0x3e, 0xa7, 0x2a,
	0xac, 0x13, 0x00, 0x00,
}

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ grpc.ClientConn

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
const _ = grpc.SupportPackageIsVersion4

// ObserverClient is the client API for Observer service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://godoc.org/google.golang.org/grpc#ClientConn.NewStream.
type ObserverClient interface {
	// GetFlows returning structured data, meant to eventually obsolete GetLastNFlows.
	GetFlows(ctx context.Context, in *GetFlowsRequest, opts ...grpc.CallOption) (Observer_GetFlowsClient, error)
	// ServerStatus returns some details about the running hubble server.
	ServerStatus(ctx context.Context, in *ServerStatusRequest, opts ...grpc.CallOption) (*ServerStatusResponse, error)
}

type observerClient struct {
	cc *grpc.ClientConn
}

func NewObserverClient(cc *grpc.ClientConn) ObserverClient {
	return &observerClient{cc}
}

func (c *observerClient) GetFlows(ctx context.Context, in *GetFlowsRequest, opts ...grpc.CallOption) (Observer_GetFlowsClient, error) {
	stream, err := c.cc.NewStream(ctx, &_Observer_serviceDesc.Streams[0], "/observer.Observer/GetFlows", opts...)
	if err != nil {
		return nil, err
	}
	x := &observerGetFlowsClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type Observer_GetFlowsClient interface {
	Recv() (*GetFlowsResponse, error)
	grpc.ClientStream
}

type observerGetFlowsClient struct {
	grpc.ClientStream
}

func (x *observerGetFlowsClient) Recv() (*GetFlowsResponse, error) {
	m := new(GetFlowsResponse)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *observerClient) ServerStatus(ctx context.Context, in *ServerStatusRequest, opts ...grpc.CallOption) (*ServerStatusResponse, error) {
	out := new(ServerStatusResponse)
	err := c.cc.Invoke(ctx, "/observer.Observer/ServerStatus", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// ObserverServer is the server API for Observer service.
type ObserverServer interface {
	// GetFlows returning structured data, meant to eventually obsolete GetLastNFlows.
	GetFlows(*GetFlowsRequest, Observer_GetFlowsServer) error
	// ServerStatus returns some details about the running hubble server.
	ServerStatus(context.Context, *ServerStatusRequest) (*ServerStatusResponse, error)
}

// UnimplementedObserverServer can be embedded to have forward compatible implementations.
type UnimplementedObserverServer struct {
}

func (*UnimplementedObserverServer) GetFlows(req *GetFlowsRequest, srv Observer_GetFlowsServer) error {
	return status.Errorf(codes.Unimplemented, "method GetFlows not implemented")
}
func (*UnimplementedObserverServer) ServerStatus(ctx context.Context, req *ServerStatusRequest) (*ServerStatusResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ServerStatus not implemented")
}

func RegisterObserverServer(s *grpc.Server, srv ObserverServer) {
	s.RegisterService(&_Observer_serviceDesc, srv)
}

func _Observer_GetFlows_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(GetFlowsRequest)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(ObserverServer).GetFlows(m, &observerGetFlowsServer{stream})
}

type Observer_GetFlowsServer interface {
	Send(*GetFlowsResponse) error
	grpc.ServerStream
}

type observerGetFlowsServer struct {
	grpc.ServerStream
}

func (x *observerGetFlowsServer) Send(m *GetFlowsResponse) error {
	return x.ServerStream.SendMsg(m)
}

func _Observer_ServerStatus_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ServerStatusRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ObserverServer).ServerStatus(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/observer.Observer/ServerStatus",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ObserverServer).ServerStatus(ctx, req.(*ServerStatusRequest))
	}
	return interceptor(ctx, in, info, handler)
}

var _Observer_serviceDesc = grpc.ServiceDesc{
	ServiceName: "observer.Observer",
	HandlerType: (*ObserverServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "ServerStatus",
			Handler:    _Observer_ServerStatus_Handler,
		},
	},
	Streams: []grpc.StreamDesc{
		{
			StreamName:    "GetFlows",
			Handler:       _Observer_GetFlows_Handler,
			ServerStreams: true,
		},
	},
	Metadata: "observer.proto",
}
